### Принципы организации хранения данных на физическом уровне в РСУБД (страничная организация, ввод/вывод, представление типов данных, пользовательские типы данных)

Физический уровень определяет, как данные реально хранятся на диске и в памяти. Понимание этих принципов критично для оптимизации производительности и эффективного администрирования.

---

### **Часть 1. Страничная организация и управление вводом/выводом (I/O)**

**Основная идея:** Для эффективной работы с диском (медленным устройством по сравнению с RAM) данные организуются в блоки фиксированного или переменного размера, называемые **страницами** (pages) или **блоками** (blocks).

#### **1.1. Страница (Page) — фундаментальная единица хранения**
*   **Размер:** Фиксирован, обычно от 4 КБ до 64 КБ (в SQL Server по умолчанию 8 КБ, в Oracle — блоки по 8 КБ, в PostgreSQL — 8 КБ, в MySQL InnoDB — 16 КБ). Определяется при создании БД и редко меняется.
*   **Структура страницы (на примере табличной страницы):**
    1.  **Заголовок страницы (Page Header):** Служебная информация — идентификатор страницы, ссылки на соседние страницы (в doubly-linked list), уровень фрагментации, сумма контрольных слов (checksum).
    2.  **Массив слотов строк (Row Offset Array):** Расположен в конце страницы. Это указатели (смещения) на начало каждой строки в области данных. Позволяет быстро найти строку по номеру.
    3.  **Область данных (Data Area):** Занимает основную часть страницы. Здесь хранятся фактические строки таблицы.
    4.  **Свободное пространство (Free Space):** Пространство между областью данных и массивом слотов для вставки новых строк или расширения существующих.

#### **1.2. Принципы работы с памятью: буферный пул (Buffer Pool)**
*   **Буферный кэш:** Выделенная область оперативной памяти СУБД для кэширования страниц с диска. При запросе данных:
    1.  СУБД проверяет, есть ли нужная страница в **буферном пуле**.
    2.  Если есть (**попадание в кэш**), данные считываются из памяти (микросекунды).
    3.  Если нет (**промах кэша**), СУБД находит страницу на диске и загружает её в буферный пул, возможно, вытесняя другую страницу (по алгоритму **LRU — Least Recently Used**).
*   **«Грязные» страницы (Dirty Pages):** Страницы, изменённые в памяти, но ещё не записанные на диск. Запись происходит асинхронно **фоновым процессом записи (Checkpoint)** для минимизации блокировок и латентности пользовательских операций.

#### **1.3. Модели ввода/вывода**
*   **Логический ввод-вывод (Logical I/O, LIO):** Обращение к странице в буферном пуле (быстро).
*   **Физический ввод-вывод (Physical I/O, PIO):** Обращение к диску (медленно). Главная цель оптимизации — **минимизировать PIO** за счёт увеличения **LIO** (эффективного кэширования).
*   **Последовательное чтение (Sequential Read):** Чтение смежных страниц (например, полное сканирование таблицы). Эффективно, так как диск хорошо работает с длинными последовательностями.
*   **Случайное чтение (Random Read):** Чтение страниц, разбросанных по диску (например, доступ по некластеризованному индексу). Медленно, особенно для HDD.

#### **1.4. Extent (Экстент) — единица выделения пространства**
*   **Определение:** Несколько (обычно 8) физически непрерывных страниц. Например, экстент размером 64 КБ = 8 страниц по 8 КБ.
*   **Назначение:** Для больших объектов (таблиц, индексов) пространство выделяется не постранично, а целыми экстентами, что снижает накладные расходы на управление и фрагментацию.

---

### **Часть 2. Физическое представление типов данных**

СУБД хранит не «цифры» и «строки» в привычном виде, а их **бинарные представления**.

| **Логический тип** | **Физическое представление (примеры)** | **Ключевые особенности хранения** |
| :--- | :--- | :--- |
| **INTEGER (4 байта)** | `0x0000000A` (для числа 10) | Фиксированная длина. Хранится в бинарном формате (чаще всего little-endian). Порядок байт зависит от платформы. |
| **DECIMAL/NUMERIC(p,s)** | Отдельное хранение целой и дробной части в упакованном десятичном формате или как двоично-десятичное число (BCD). | **Точный** тип. Занимает место пропорционально заданной точности. Не подвержен ошибкам округления. |
| **FLOAT/REAL** | По стандарту IEEE 754 (32 или 64 бита). | **Приближённый** тип. Меньший размер, но возможны ошибки округления. |
| **CHAR(n)** | Фиксированная строка, **дополненная пробелами** до длины `n`. | Даже если строка короче `n`, занимает всю длину. Быстрый доступ к произвольной строке по смещению. |
| **VARCHAR(n)** | **Данные + длина**. Обычно: 2 байта длины + сами символы (в кодировке, например, UTF-8). | Переменная длина. Экономит место, но требует дополнительных операций для определения границ строки. Может приводить к фрагментации страниц. |
| **DATE/TIME** | Часто хранится как целое число (количество дней/секунд от фиксированной эпохи, например, 01.01.1970). | Преобразование в человекочитаемый формат — задача СУБД. |
| **BLOB (Binary Large Object)** | **Внестраничное хранение**. В строке таблицы хранится только **указатель (ссыллка)**, а сами данные размещаются в отдельных спец. страницах (LOB-страницах). | Позволяет не перегружать основные страницы таблицы большими данными, сохраняя эффективность работы с основной частью строки. |

**NULL-значения:** Обычно реализуются через **битовую карту NULL** (NULL bitmap) в заголовке строки. Отдельный бит указывает, является ли значение в столбце NULL, что экономит место (не нужно хранить специальное значение в ячейке данных).

---

### **Часть 3. Пользовательские типы данных (User-Defined Types, UDT)**

Это механизм расширения системы типов СУБД для лучшего соответствия предметной области.

#### **3.1. Типы на основе существующих (Domain Types, Псевдонимы типов)**
*   **Назначение:** Создать семантически понятное имя для стандартного типа с добавлением **проверочных ограничений (CHECK)**.
*   **Пример (SQL):**
    ```sql
    CREATE DOMAIN EmailAddress AS VARCHAR(255)
        CHECK (VALUE ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');
    -- Теперь тип EmailAddress можно использовать в таблицах
    CREATE TABLE Users (
        user_email EmailAddress
    );
    ```
*   **Польза:** Повышение семантической ясности, централизованное управление ограничениями.

#### **3.2. Составные (структурные) типы (Composite Types)**
*   **Назначение:** Объединить несколько атрибутов в одну логическую единицу (аналог структуры в C или записи в Pascal).
*   **Пример (PostgreSQL):**
    ```sql
    CREATE TYPE AddressType AS (
        city VARCHAR(90),
        street VARCHAR(90),
        house VARCHAR(10)
    );
    CREATE TABLE Companies (
        company_id SERIAL PRIMARY KEY,
        office_address AddressType
    );
    -- Обращение к полю: (office_address).city
    ```
*   **Польза:** Моделирование сложных атрибутов без создания лишних таблиц. Может нарушать 1НФ, но это осознанное решение для упрощения модели.

#### **3.3. Объектные типы (Object Types)**
*   **Назначение:** Поддержка объектно-ориентированной парадигмы в БД (методы, наследование). Наиболее развиты в **Oracle**.
*   **Пример (Oracle PL/SQL):**
    ```sql
    CREATE TYPE PersonType AS OBJECT (
        id NUMBER,
        name VARCHAR2(100),
        MEMBER FUNCTION get_info RETURN VARCHAR2
    );
    CREATE TYPE Body PersonType AS
        MEMBER FUNCTION get_info RETURN VARCHAR2 IS
        BEGIN
            RETURN 'ID: ' || SELF.id || ', Name: ' || SELF.name;
        END;
    -- Создание таблицы объектов
    CREATE TABLE People OF PersonType;
    ```
*   **Польза:** Позволяет хранить сложное поведение (методы) вместе с данными, что полезно для некоторых бизнес-моделей.

#### **3.4. Преимущества и недостатки пользовательских типов**
| **Преимущества** | **Недостатки** |
| :--- | :--- |
| **Абстракция и повторное использование:** Логически связанные атрибуты группируются. | **Сложность миграции:** Усложняет перенос БД в другую СУБД, где такого типа может не быть. |
| **Семантическая ясность:** Код и схема БД становятся понятнее. | **Снижение портативности:** Не все инструменты и ORM корректно работают с UDT. |
| **Централизация ограничений:** Изменение правила валидации в одном месте (домене). | **Производительность:** Сложные UDT могут требовать дополнительной обработки. |
| **Целостность данных:** Встроенные проверки на уровне типа. | **Сложность администрирования:** Требуют дополнительных знаний для управления. |

---

#### **4. Заключение**

Физическая организация данных в РСУБД — это сложный компромисс между:
*   **Эффективностью использования диска** (страницы, экстенты).
*   **Скоростью доступа** (буферный кэш, минимизация I/O).
*   **Гибкостью представления информации** (типы данных, UDT).

Понимание этих принципов позволяет:
1.  Осознанно выбирать типы данных (например, `CHAR` vs `VARCHAR`).
2.  Правильно интерпретировать планы запросов (прогнозировать количество логических/физических чтений).
3.  Проектировать эффективные схемы хранения (с учётом размера строк и страниц).
4.  Принимать решения о необходимости использования пользовательских типов для улучшения модели данных.