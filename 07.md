### Управление производительностью промышленных СУБД. Показатели производительности запросов к базам данных.

Управление производительностью СУБД — это непрерывный циклический процесс (Performance Tuning Lifecycle), направленный на выполнение бизнес-требований (SLA) при оптимальном использовании ресурсов. Он основан на измерении, анализе и устранении "узких мест".

---

### **Часть 1. Показатели производительности запросов и системы**

Метрики делятся на два основных класса: **метрики отклика (задержки)** и **метрики пропускной способности**.

#### **1.1. Метрики отклика (Latency Metrics) — "Насколько быстро?"**

*   **Время выполнения запроса (Query Execution Time/Elapsed Time):** Полное время от отправки запроса до получения последней строки результата клиентом. **Ключевой показатель для пользователя.**
*   **Время ожидания (Wait Time):** Часть общего времени, которую запрос провел в очередях, ожидая ресурсов (CPU, I/O, блокировок). **Показатель конкуренции и проблем.**
*   **Время ЦП (CPU Time):** Фактическое время процессорной обработки запроса. В идеале `Elapsed Time ≈ CPU Time`. Если `Elapsed >> CPU` — есть ожидания.
*   **Время логических/физических чтений (Logical/Physical Reads):**
    *   **Логическое чтение (Logical Read):** Обращение к странице данных из **буферного кэша**. Высокое значение может указывать на неоптимальность запроса (лишние сканирования).
    *   **Физическое чтение (Physical Read):** Обращение к странице с **диска**. Медленная операция. Высокое значение указывает на нехватку памяти (буферного кэша) или на полное сканирование больших таблиц.
*   **Время первого байта (Time to First Byte):** Важно для веб-приложений, показывает, как быстро система начала отдавать результат.

#### **1.2. Метрики пропускной способности (Throughput Metrics) — "Сколько в единицу времени?"**

*   **Количество транзакций в секунду (TPS — Transactions Per Second):** Интегральный показатель нагрузки на OLTP-систему.
*   **Количество запросов в секунду (QPS — Queries Per Second):** Часто используется для аналитических и веб-систем.
*   **Количество операций ввода-вывода в секунду (IOPS):** Показатель активности дисковой подсистемы. Различают IOPS на чтение и запись.
*   **Пропускная способность сети (Network Throughput):** Объем данных, передаваемый между СУБД и клиентами.

#### **1.3. Метрики эффективности и использования ресурсов**

*   **Коэффициент попадания в кэш (Buffer Cache Hit Ratio, BCHR):** `(Logical Reads - Physical Reads) / Logical Reads * 100%`. Показывает, насколько эффективно буферный кэш удовлетворяет запросы. Целевое значение > 98-99% для OLTP.
*   **Среднее время отклика диска (Disk Avg. Read/Write Latency):** Ключевая метрика здоровья дисковой подсистемы. Для SSD — доли миллисекунды, для HDD — единицы миллисекунд. Рост указывает на перегрузку.
*   **Загрузка ЦП (CPU Utilization):** Устойчивая загрузка > 70-80% часто свидетельствует о недостатке вычислительных ресурсов или неоптимальных планах запросов.
*   **Конкурентная активность:**
    *   **Количество блокировок/взаимных блокировок (Locks/Deadlocks/sec).**
    *   **Длина очереди на дисковые операции.**
    *   **Количество активных/ожидающих сессий.**

---

### **Часть 2. Системный подход к управлению производительностью**

Цель — найти и устранить **"узкое место" (bottleneck)**, которое ограничивает общую производительность. После устранения одного узкого места проявляется следующее.

**Формула системного подхода: Производительность = (Рабочая нагрузка) / (Конфликты + Очереди)**

#### **Этап 1. Мониторинг и сбор базовых показателей (Establish a Baseline)**
*   **Что делать:** Постоянно собирать ключевые метрики (см. Часть 1) в периоды нормальной работы. Использовать:
    *   Встроенные средства СУБД: **Динамические административные представления (DMV)** в SQL Server, `V$`-представления и AWR в Oracle, `pg_stat_*` в PostgreSQL.
    *   Системные мониторы: PerfMon (Windows), `vmstat`, `iostat`, `top` (Linux).
    *   Специализированные платформы мониторинга: Zabbix, Prometheus + Grafana, коммерческие решения.
*   **Зачем:** Без "нормы" невозможно выявить "проблему". Определяются типичные значения TPS, загрузки CPU, IOPS.

#### **Этап 2. Выявление проблемных запросов и "узких мест"**
*   **Метод 80/20:** 20% запросов создают 80% нагрузки. Необходимо их найти.
    *   **Инструменты:** Query Store (SQL Server), Automatic Workload Repository (AWR) и ASH (Oracle), `pg_stat_statements` (PostgreSQL).
    *   **Ищем запросы с:**
        1.  Наибольшим **общим временем выполнения (Total Elapsed Time)**.
        2.  Наибольшим количеством **логических/физических чтений**.
        3.  Наибольшим **временем ЦП**.
        4.  Плохой **стабильностью** (сильные колебания времени выполнения).

#### **Этап 3. Детальная диагностика выбранного запроса (Анализ плана выполнения)**
План выполнения (Execution Plan) — это пошаговая инструкция СУБД о том, **как** получить данные. Это основа для оптимизации.

*   **Ключевые операции в плане, указывающие на проблемы:**
    *   **Table Scan / Full Index Scan:** Полное сканирование таблицы или большого индекса. Часто признак отсутствия подходящего индекса.
    *   **Key Lookup (Bookmark Lookup) / RID Lookup:** Дорогая операция "прыжка" от некластеризованного индекса к строке данных в куче или кластеризованном индексе. Причина — неполный покрывающий индекс.
    *   **Sort (явная сортировка), Hash Join (для маленьких наборов):** Могут быть признаком отсутствия индекса для `ORDER BY` или неправильного выбора типа соединения оптимизатором.
    *   **Высокая расчетная кардинальность vs низкая фактическая:** Указывает на устаревшую статистику, из-за которой оптимизатор выбрал неэффективный план.
    *   **Параллельное выполнение (CXPACKET wait)** для маленьких запросов: Избыточность, трата ресурсов.

#### **Этап 4. Применение методов оптимизации (От общего к частному)**

**Уровень 4.1: Аппаратная и конфигурационная оптимизация (Быстрый выигрыш)**
*   **Увеличить память:** Увеличение буферного кэша снижает Physical Reads.
*   **Перейти на быстрые SSD (NVMe):** Кардинально снижает время случайных чтений.
*   **Оптимизировать конфигурацию СУБД:** Размер буферного пула, максимальная степень параллелизма (`MAXDOP`), стоимость порога для параллелизма, настройки автосбора статистики.

**Уровень 4.2: Оптимизация схемы и индексов (Наибольший и устойчивый эффект)**
*   **Создание отсутствующих индексов:** Индекс по условиям `WHERE`, `JOIN`, `ORDER BY`.
*   **Оптимизация существующих индексов:**
    *   Создание **покрывающих индексов (INCLUDE)**, устраняющих Key Lookup.
    *   **Удаление неиспользуемых и дублирующих индексов** (они замедляют DML).
    *   Регулярное **обслуживание индексов** (перестроение, реорганизация) для борьбы с фрагментацией.
*   **Партиционирование таблиц:** Разделение большой таблицы на логические/физические части. Ускоряет операции удаления (DROP PARTITION) и направленное сканирование.

**Уровень 4.3: Оптимизация текста запроса (Переписывание логики)**
*   **Убрать лишние колонки** в `SELECT` (особенно `SELECT *`).
*   **Избегать не-SARGable предикатов:** Функции над полями в `WHERE` (`WHERE YEAR(date) = 2023`) не позволяют использовать индекс. Замена на диапазон (`WHERE date >= '2023-01-01'`).
*   **Замена коррелированных подзапросов** на `JOIN`.
*   **Использование временных таблиц/CTE** для упрощения сложных запросов.
*   **Пересмотр логики:** Можно ли получить результат другим, более эффективным способом?

**Уровень 4.4: Управление планами выполнения (Продвинутый уровень)**
*   **Обновление статистики:** Устаревшая статистика — главная причина выбора плохого плана.
*   **Использование подсказок оптимизатора (Query Hints):** `OPTION (RECOMPILE)`, `FORCE ORDER`, `INDEX()`. **Применять с крайней осторожностью!**
*   **Принудительная фиксация хорошего плана (Plan Forcing):** Query Store (SQL Server), SQL Plan Baselines (Oracle).

#### **Этап 5. Верификация изменений и контроль регрессий**
После внесения изменений (добавления индекса, переписывания запроса) **обязательно**:
1.  Сравнить новые планы выполнения со старыми.
2.  Измерить ключевые метрики (время, чтения) для запроса.
3.  Оценить влияние на общую нагрузку системы.
4.  Внедрить изменения в промышленную среду через процесс тестирования.

---

### **3. Заключение и сводная таблица методов**

**Золотые правила оптимизации:**
1.  **Измеряй, не гадай.** Всегда опирайтесь на метрики и планы выполнения.
2.  **Ищи "узкое место".** Нельзя ускорять систему вообще, можно устранять конкретную проблему.
3.  **Индексы — главный инструмент.** Но их нужно правильно проектировать и поддерживать.
4.  **Запрос — это то, что вы написали.** Часто проблема в логике запроса, а не в СУБД.
5.  **Оптимизация — это компромисс.** Ускорение чтения может замедлить запись. Изменения нужно тестировать.

| **"Узкое место" / Симптом** | **Возможные причины** | **Методы диагностики** | **Методы оптимизации** |
| :--- | :--- | :--- | :--- |
| **Высокий CPU** | Неоптимальные планы запросов (сканирования, хэш-соединения), компиляция планов. | Анализ планов, поиск запросов с высоким CPU Time, `sys.dm_os_wait_stats` (SOS_SCHEDULER_YIELD). | Оптимизация запросов, добавление индексов, обновление статистики, увеличение CPU/ядер. |
| **Высокая задержка диска (I/O)** | Нехватка буферного кэша, отсутствие индексов (сканирования), медленные диски. | Buffer Cache Hit Ratio, отслеживание Physical Reads в планах запросов, мониторинг `avg. disk sec/read`. | Увеличение памяти, переход на SSD, добавление индексов, партиционирование. |
| **Блокировки (Locks)** | Длительные транзакции, неоптимальные запросы, отсутствие индексов (блокировка больших диапазонов), высокий уровень изоляции. | Мониторинг `sys.dm_tran_locks`, `sys.dm_os_waiting_tasks` (LCK_M_*). | Оптимизация транзакций (быстрее выполняются, меньше блокируют), использование `READ COMMITTED SNAPSHOT`, индексы для точного поиска. |
| **Параллелизм (CXPACKET)** | Параллельное выполнение мелких запросов, смещение распределения данных. | Анализ планов (значки параллелизма), `sys.dm_os_wait_stats`. | Настройка `MAXDOP` и `Cost Threshold for Parallelism`, обновление статистики, переписывание запроса. |