### Понятие курсора. Операции с курсорами

### **Часть 1. Понятие и назначение курсора**

**Курсор (Cursor)** — это объект базы данных, который позволяет **последовательно, построчно (row-by-row)** обрабатывать результирующий набор данных, возвращаемый запросом `SELECT`.

**Основная проблема, которую решает курсор:** SQL — это **наборно-ориентированный (set-based)** язык. Операции выполняются над всеми строками одновременно. Курсор же предоставляет механизм для **императивной, построчной обработки**, когда логика алгоритма требует последовательного прохода по строкам с выполнением различных действий для каждой.

**Аналогия:** Результирующий набор — это таблица в Excel. Обычный SQL-запрос работает как "применить формулу ко всему столбцу". Курсор — это "пройти по каждой строке таблицы с помощью макроса, который может по-разному обрабатывать каждую ячейку".

#### **Внутренняя структура курсора:**
1.  **Результирующий набор (Result Set):** Данные, полученные из `SELECT`-запроса.
2.  **Позиция курсора (Cursor Position):** Указатель на текущую строку в результирующем наборе.
3.  **Область памяти (Cursor Buffer):** Выделенная область в памяти сервера или клиента для хранения текущей строки и, возможно, других строк.

---

### **Часть 2. Классификация курсоров**

Курсоры классифицируются по нескольким ключевым свойствам, которые определяют их поведение, производительность и потребление ресурсов.

#### **1. По области видимости и времени жизни:**
*   **Локальный (`LOCAL`):** Объявляется и доступен только в пакете, процедуре, триггере, где он создан. Уничтожается автоматически при выходе из области видимости.
*   **Глобальный (`GLOBAL`):** Доступен из любого соединения или пакета в рамках текущего сеанса. Существует до явного закрытия или конца сеанса. **Использовать с осторожностью!**

#### **2. По возможности изменения данных (Чувствительность):**
*   **Статический (`STATIC`) (Нечувствительный):** Создает временную копию данных в `tempdb` на момент открытия. Не отражает изменения, произошедшие в исходных таблицах после открытия. Ресурсоемкий, но стабильный.
*   **Динамический (`DYNAMIC`) (Чувствительный):** Отражает все изменения, сделанные другими пользователями в базовых таблицах (вставки, удаления, обновления). Самый ресурсоемкий, позиция строк может меняться.
*   **Набор ключей (`KEYSET`) (Частично чувствительный):** Сохраняет только ключи строк (обычно из первичного ключа) в временной таблице. Отражает обновления данных в существующих строках, но **не видит** новые вставленные или удаленные строки.
*   **Быстроходный вперед (`FAST_FORWARD`) (Оптимизированный):** Гибрид `FORWARD_ONLY` и `READ_ONLY`. Наиболее производительный вариант для однопроходного чтения. Не позволяет обновлять данные и двигаться назад.

#### **3. По направлению навигации:**
*   **Только вперед (`FORWARD_ONLY`):** Курсор может перемещаться только от первой к последней строке. Самый быстрый тип.
*   **Прокручиваемый (`SCROLL`):** Курсор может перемещаться в любом направлении (`FIRST`, `LAST`, `PRIOR`, `NEXT`, `RELATIVE`, `ABSOLUTE`).

#### **4. По возможности модификации данных:**
*   **Только для чтения (`READ_ONLY`):** Данные через курсор нельзя изменить.
*   **Обновляемый (`UPDATE ... OF column_list`)**: Позволяет обновлять или удалять текущую строку через курсор.

---

### **Часть 3. Жизненный цикл и операции с курсором в T-SQL**

Работа с курсором — это строгая последовательность шагов (DECLARE, OPEN, FETCH, CLOSE, DEALLOCATE).

#### **Этап 1: Объявление курсора (`DECLARE CURSOR`)**
Определяет запрос и свойства курсора.

```sql
DECLARE cursor_name CURSOR 
    [ LOCAL | GLOBAL ]                     -- Область видимости
    [ FORWARD_ONLY | SCROLL ]              -- Направление
    [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ] -- Тип
    [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ] -- Блокировки
    [ TYPE_WARNING ]                       -- Предупреждение о неявном преобразовании
FOR select_statement                       -- Запрос, формирующий набор
[ FOR UPDATE [ OF column_name [ ,...n ] ] ]; -- Возможность обновления
```

**Пример:**
```sql
DECLARE EmployeeCursor CURSOR 
    LOCAL STATIC FORWARD_ONLY READ_ONLY
FOR 
    SELECT EmployeeID, LastName, FirstName, Salary
    FROM dbo.Employees
    WHERE DepartmentID = 5
    ORDER BY LastName;
```

#### **Этап 2: Открытие курсора (`OPEN`)**
Выполняет связанный `SELECT`-запрос, заполняет результирующий набор и позиционирует курсор **перед первой строкой**.

```sql
OPEN EmployeeCursor;
```

#### **Этап 3: Выборка строк (`FETCH`)**
Извлекает данные из текущей строки и перемещает курсор.

```sql
-- Основные варианты FETCH:
FETCH NEXT FROM EmployeeCursor;           -- Следующая строка (для FORWARD_ONLY)
FETCH FIRST FROM EmployeeCursor;          -- Первая строка (требует SCROLL)
FETCH PRIOR FROM EmployeeCursor;          -- Предыдущая строка (требует SCROLL)
FETCH ABSOLUTE 5 FROM EmployeeCursor;     -- 5-я строка от начала (требует SCROLL)
FETCH RELATIVE -2 FROM EmployeeCursor;    -- На 2 строки назад (требует SCROLL)
FETCH LAST FROM EmployeeCursor;           -- Последняя строка (требует SCROLL)
```

**Для обработки данных** нужно поместить значения в переменные:
```sql
DECLARE @EmpID INT, @LastName NVARCHAR(50), @FirstName NVARCHAR(50), @Salary DECIMAL(10,2);

-- Извлечение данных текущей строки в переменные
FETCH NEXT FROM EmployeeCursor 
INTO @EmpID, @LastName, @FirstName, @Salary;

-- Проверка статуса выборки
WHILE @@FETCH_STATUS = 0  -- 0 = успешно извлекли строку
BEGIN
    -- Логика обработки строки
    PRINT CONCAT('Сотрудник: ', @LastName, ' ', @FirstName, ', ЗП: ', @Salary);
    
    -- Следующая строка
    FETCH NEXT FROM EmployeeCursor 
    INTO @EmpID, @LastName, @FirstName, @Salary;
END
```
*   **`@@FETCH_STATUS`**: Системная функция, возвращающая статус последней операции `FETCH`.
    *   **0**: Успешно.
    *   **-1**: Строка не найдена (конец набора данных или строка удалена).
    *   **-2**: Строка отсутствует (например, была удалена из `KEYSET` курсора).

#### **Этап 4: Обновление/удаление через курсор (опционально)**
Если курсор объявлен с `FOR UPDATE`:
```sql
-- Удаление текущей строки
DELETE FROM dbo.Employees 
WHERE CURRENT OF EmployeeCursor;

-- Обновление текущей строки
UPDATE dbo.Employees 
SET Salary = Salary * 1.1 
WHERE CURRENT OF EmployeeCursor;
```

#### **Этап 5: Закрытие курсора (`CLOSE`)**
Освобождает текущий результирующий набор и блокировки, но **оставляет структуру курсора доступной** для повторного открытия (`OPEN`).
```sql
CLOSE EmployeeCursor;
```

#### **Этап 6: Освобождение ресурсов (`DEALLOCATE`)**
Полностью удаляет определение курсора из памяти, освобождает все связанные с ним ресурсы. После этого курсор нельзя повторно открыть.
```sql
DEALLOCATE EmployeeCursor;
```

**Полный типичный цикл:**
```sql
DECLARE @ID INT, @Name NVARCHAR(100);
DECLARE MyCursor CURSOR LOCAL FAST_FORWARD FOR 
    SELECT Id, Name FROM MyTable;

OPEN MyCursor;
FETCH NEXT FROM MyCursor INTO @ID, @Name;

WHILE @@FETCH_STATUS = 0
BEGIN
    -- Обработка данных
    PRINT CONCAT('Обрабатывается ID=', @ID, ', Name=', @Name);
    
    FETCH NEXT FROM MyCursor INTO @ID, @Name;
END

CLOSE MyCursor;
DEALLOCATE MyCursor;
```

---

### **Часть 4. Преимущества, недостатки и альтернативы**

#### **Преимущества курсоров (ограниченные):**
1.  **Возможность построчной обработки** со сложной условной логикой.
2.  **Обновление/удаление конкретных строк** по сложным критериям, которые трудно выразить в одном `UPDATE`.
3.  **Административные задачи:** Последовательный обход системных таблиц для генерации динамического SQL.

#### **Критические недостатки (почему курсоры — «последнее средство»):**
1.  **Низкая производительность (Основной минус):** Каждая операция `FETCH` — это отдельный вызов сервера, что приводит к высокой нагрузке на CPU и высокому сетевому трафику (при клиентских курсорах). Нарушает принцип работы СУБД с наборами данных.
2.  **Блокировки:** Курсоры могут удерживать блокировки на длительное время, снижая параллелизм и вызывая взаимоблокировки (deadlocks).
3.  **Высокое потребление ресурсов:** Требуют выделения памяти и ресурсов `tempdb` (для `STATIC`, `KEYSET`).
4.  **Сложность сопровождения:** Код с курсорами часто запутан и сложен для понимания по сравнению с декларативными запросами.

#### **Альтернативы курсорам (предпочтительные методы):**

| **Сценарий, где хочется использовать курсор** | **Рекомендуемая альтернатива на T-SQL** |
| :--- | :--- |
| **Последовательная обработка строк с аккумуляцией** | **`WHILE` цикл по табличной переменной или временной таблице:** Сначала `INSERT` всех данных во временную структуру, затем цикл. Часто быстрее курсора. |
| **Сложные пошаговые расчеты для каждой строки** | **Оконные функции (`OVER()`):** `LAG()`, `LEAD()`, `SUM() OVER()`. Идеально для расчетов, зависящих от других строк. |
| **Агрегация с условиями** | **`CASE` внутри агрегатных функций:** `SUM(CASE WHEN condition THEN value END)`. |
| **Операции, зависящие от предыдущего результата (running total)** | **Рекурсивный CTE (`WITH RECURSIVE`):** Для иерархических данных или последовательностей. |
| **Выполнение операций для каждого элемента списка** | **Числовая или табличная функция, возвращающая набор строк:** Затем `JOIN` с основной таблицей. |
| **Массовые обновления по сложной логике** | **Коррелированные подзапросы или `UPDATE` с `FROM` и `JOIN`:** Позволяют обновлять данные на основе других таблиц. |

**Золотое правило:** **Всегда старайтесь сначала найти наборное (set-based) решение.** Используйте курсоры **только тогда, когда:**
1.  Логика обработки **действительно требует** последовательного доступа к строкам (например, вызов внешней процедуры для каждой строки).
2.  **Объем обрабатываемых данных невелик** (сотни, тысячи строк).
3.  **Производительность не является критичным фактором** (административные скрипты, разовые задачи).

---

### **3. Заключение**

Курсор — это мощный, но **очень опасный** инструмент. Он нарушает основную парадигму SQL (работу с наборами) и вводит императивный стиль, к которому СУБД не оптимизированы. Современные версии T-SQL (с оконными функциями, улучшенными CTE, табличными переменными) предоставляют значительно более эффективные способы решения большинства задач, для которых раньше требовались курсоры.

**Для экзамена важно понимать:** механику работы курсора, его жизненный цикл, но еще важнее — **понимать, когда его применение оправдано, а когда существуют более эффективные альтернативы.** Умение преобразовать курсорный алгоритм в наборную операцию — признак высокой квалификации SQL-разработчика.