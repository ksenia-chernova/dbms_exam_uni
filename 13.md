### Понятие представлений. Создание представлений с помощью Transact-SQL

### **Часть 1. Понятие и назначение представлений**

**Представление (View)** — это **виртуальная таблица**, результат сохраненного запроса `SELECT`. Оно не содержит данных физически, а представляет собой **набор именованных столбцов и строк**, который динамически извлекается из одной или нескольких базовых таблиц при каждом обращении к представлению.

**Ключевая аналогия:** Представление — это **"сохраненный запрос"** или **"виртуальное окно"** через которое пользователь видит данные. Как окно в доме не содержит мебели, но показывает ее внутри, так и представление не хранит строки, но показывает данные из других таблиц.

#### **Внутренняя организация:**
*   В системном каталоге СУБД хранится **только определение представления** (текст запроса `SELECT`).
*   При выполнении запроса к представлению (`SELECT * FROM MyView`) оптимизатор **"разворачивает"** его определение, подставляя его в основной запрос, и строит единый план выполнения для всего запроса.

#### **Назначение и цели представлений:**

| Цель | Описание |
| :--- | :--- |
| **Упрощение сложных запросов** | Скрытие сложных `JOIN`, агрегаций, подзапросов за простым интерфейсом. |
| **Обеспечение безопасности** | Ограничение доступа пользователей только к определенным столбцам (`column-level security`) или строкам (`row-level security`) базовых таблиц. |
| **Абстракция от физической схемы** | Изоляция клиентских приложений от изменений в структуре таблиц (можно изменить представление, не трогая приложение). |
| **Организация данных** | Логическое структурирование данных для разных групп пользователей (представления `Sales.vw_Customers`, `HR.vw_Employees`). |
| **Обеспечение обратной совместимости** | Если старые приложения используют удаленную таблицу, ее можно заменить на представление с тем же именем. |

---

### **Часть 2. Типы представлений**

#### **1. Стандартное (неиндексированное) представление**
*   **Не** хранит данные.
*   При каждом обращении выполняется запрос к базовым таблицам.
*   Самый распространенный тип.

#### **2. Индексированное представление (Materialized View / Indexed View)**
*   **Физически хранит данные** на диске в виде кластеризованного индекса.
*   Данные автоматически обновляются при изменении базовых таблиц.
*   **Назначение:** Значительно ускорить выполнение сложных агрегирующих запросов в OLAP-системах ценой замедления DML-операций.
*   **Требования:** Строгие ограничения на определение (нельзя `DISTINCT`, `OUTER JOIN`, подзапросы в некоторых СУБД).

#### **3. Разделенное представление (Partitioned View)**
*   Объединяет горизонтально разделенные данные из нескольких таблиц (возможно, на разных серверах) в единое логическое целое.
*   Может быть обновляемым (в SQL Server Enterprise Edition).
*   **Альтернатива:** Сейчас чаще используют **секционирование таблиц (table partitioning)**.

---

### **Часть 3. Создание и управление представлениями в T-SQL**

#### **3.1. Создание представления (`CREATE VIEW`)**

**Базовый синтаксис:**
```sql
CREATE VIEW [schema_name.]view_name [(column_name [, ...n])]
[WITH { ENCRYPTION | SCHEMABINDING | VIEW_METADATA } [, ...]]
AS
    select_statement
[WITH CHECK OPTION];
```

**Ключевые компоненты:**

1.  **Имя и столбцы:**
    ```sql
    CREATE VIEW dbo.vw_ActiveCustomers  -- Имя в схеме dbo
    (
        CustomerID,  -- Явные имена столбцов (опционально)
        FullName,    -- Полезно, если в SELECT есть вычисления
        Region,
        TotalOrders
    )
    ```

2.  **Опции создания (`WITH`):**
    *   **`ENCRYPTION`** — шифрует текст представления в системных таблицах. **Важно:** Нет возможности восстановить текст, всегда храните исходный код отдельно!
    *   **`SCHEMABINDING`** — привязывает представление к схемам базовых объектов. Запрещает изменять эти объекты способом, который может повлиять на представление. **Обязательно для индексированных представлений.**
    *   **`VIEW_METADATA`** — при запросе через API (например, ODBC) возвращает метаданные столбцов представления, а не базовых таблиц.

3.  **Тело представления (`AS select_statement`):**
    *   Может содержать почти любой допустимый `SELECT` (с ограничениями для индексированных представлений).
    *   Не может содержать `ORDER BY` без `TOP`, `OFFSET-FETCH` (кроме случаев, когда есть `TOP`).
    *   Может ссылаться на другие представления.

4.  **`WITH CHECK OPTION`** — применяется только к **обновляемым представлениям**. Гарантирует, что все операции `INSERT` и `UPDATE` через представление будут удовлетворять условию `WHERE` в определении представления. Не позволяет "потерять" строку из представления через обновление.

#### **3.2. Практические примеры создания**

**Пример 1: Базовое представление для упрощения доступа**
```sql
-- Создание представления для отдела продаж
CREATE VIEW Sales.vw_CustomerOrders
WITH SCHEMABINDING  -- Запретим менять схему таблиц
AS
SELECT 
    c.CustomerID,
    c.CompanyName,
    c.ContactName,
    o.OrderID,
    o.OrderDate,
    o.Freight,
    od.Quantity,
    p.ProductName
FROM dbo.Customers c
INNER JOIN dbo.Orders o ON c.CustomerID = o.CustomerID
INNER JOIN dbo.[Order Details] od ON o.OrderID = od.OrderID
INNER JOIN dbo.Products p ON od.ProductID = p.ProductID
WHERE o.ShippedDate IS NOT NULL;  -- Только выполненные заказы
GO

-- Использование
SELECT * FROM Sales.vw_CustomerOrders 
WHERE OrderDate >= '2024-01-01';
```

**Пример 2: Представление с вычисляемыми столбцами и агрегацией**
```sql
CREATE VIEW dbo.vw_EmployeePerformance
AS
SELECT 
    e.EmployeeID,
    e.LastName + ' ' + e.FirstName AS FullName,
    e.Title,
    COUNT(o.OrderID) AS TotalOrders,
    SUM(od.Quantity * od.UnitPrice) AS TotalSalesAmount,
    YEAR(o.OrderDate) AS SalesYear
FROM dbo.Employees e
LEFT JOIN dbo.Orders o ON e.EmployeeID = o.EmployeeID
LEFT JOIN dbo.[Order Details] od ON o.OrderID = od.OrderID
GROUP BY 
    e.EmployeeID, 
    e.LastName, 
    e.FirstName, 
    e.Title,
    YEAR(o.OrderDate);
GO
```

**Пример 3: Обновляемое представление с `CHECK OPTION`**
```sql
-- Представление только для активных пользователей
CREATE VIEW dbo.vw_ActiveUsers
AS
SELECT 
    UserID,
    UserName,
    Email,
    LastLoginDate
FROM dbo.Users
WHERE IsActive = 1
WITH CHECK OPTION;  -- Критично для обновлений!

-- Эта вставка УСПЕШНА (IsActive = 1)
INSERT INTO dbo.vw_ActiveUsers (UserName, Email, IsActive) 
VALUES ('NewUser', 'new@mail.com', 1);

-- Эта вставка ПРОВАЛИТСЯ из-за CHECK OPTION (IsActive = 0)
INSERT INTO dbo.vw_ActiveUsers (UserName, Email, IsActive) 
VALUES ('Inactive', 'inactive@mail.com', 0);
-- Ошибка: "Попытка вставить или обновить строку, которая не попала в представление"
```

#### **3.3. Изменение и управление представлениями**

```sql
-- 1. Изменение существующего представления (сохраняет права)
ALTER VIEW dbo.vw_ActiveCustomers
AS
-- Новое определение
SELECT ...

-- 2. Удаление представления
DROP VIEW IF EXISTS dbo.vw_OldView;

-- 3. Просмотр определения представления
EXEC sp_helptext 'dbo.vw_ActiveCustomers';

-- 4. Получение информации о зависимостях
-- Что зависит от представления?
EXEC sp_depends 'dbo.vw_ActiveCustomers';
-- От чего зависит представление?
SELECT * FROM sys.sql_expression_dependencies
WHERE referencing_id = OBJECT_ID('dbo.vw_ActiveCustomers');

-- 5. Переименование представления
EXEC sp_rename 'dbo.vw_OldName', 'vw_NewName';
```

---

### **Часть 4. Особенности производительности, ограничения и лучшие практики**

#### **Производительность представлений:**
*   **Представление само по себе не ускоряет запросы!** При запросе к представлению оптимизатор "разворачивает" его и строит план как для обычного сложного `SELECT`.
*   **Индексированные представления** — исключение. Они действительно ускоряют запросы, но за счет:
    1.  Замедления `INSERT`/`UPDATE`/`DELETE` в базовых таблицах.
    2.  Дополнительного расхода места на диске.
    3.  Строгих ограничений на создание.

#### **Ограничения и особенности:**
1.  **Нельзя использовать `ORDER BY`** в определении представления без `TOP` или `OFFSET-FETCH` (т.к. представление — это таблица, а в таблице нет порядка по умолчанию).
2.  **Временные таблицы** нельзя использовать в определении представления.
3.  Для **обновляемых представлений** существуют ограничения:
    *   Должна затрагивать только одну таблицу (или иметь правильные `INSTEAD OF` триггеры для многотабличных представлений).
    *   Не может содержать `DISTINCT`, `GROUP BY`, агрегатные функции в основной части.
    *   Все обновляемые столбцы должны напрямую ссылаться на столбцы базовой таблицы.

#### **Лучшие практики создания представлений:**

1.  **Используйте схемы и осмысленные имена:** `Sales.vw_MonthlyReport`, `HR.vw_Employees`.
2.  **Всегда указывайте список столбцов**, если в `SELECT` есть вычисляемые выражения или дублирующиеся имена.
3.  **Используйте `SCHEMABINDING`** везде, где возможно, для защиты от изменений схемы.
4.  **Избегайте "представлений на представлениях"** глубокой вложенности — это усложняет отладку и может негативно сказаться на производительности.
5.  **Документируйте назначение представления** с помощью расширенных свойств:
    ```sql
    EXEC sp_addextendedproperty 
        @name = N'MS_Description',
        @value = N'Представление для отчета по активным заказам клиентов',
        @level0type = N'SCHEMA', @level0name = 'Sales',
        @level1type = N'VIEW', @level1name = 'vw_CustomerOrders';
    ```

#### **Сценарии, где представления незаменимы:**

1.  **Сложные отчеты:** Создание "слоя представлений" для BI-инструментов (Power BI, Tableau).
2.  **Многоуровневая безопасность:** Разные представления для разных ролей пользователей.
3.  **API доступа к данным:** Представления как стабильный интерфейс для внешних систем.
4.  **Упрощение миграции:** При переходе на новую схему данных старые приложения могут работать через представления-адаптеры.

---

### **3. Заключение**

**Представления в T-SQL — это мощный инструмент абстракции и управления доступом**, а не средство оптимизации. Они позволяют:
*   **Разделять ответственность** между разработчиками БД (сложная логика в представлениях) и разработчиками приложений (простой `SELECT * FROM View`).
*   **Создавать "логический слой"** поверх физических таблиц, что повышает гибкость и безопасность системы.
*   **Стандартизировать** часто используемые запросы во всей организации.

**Важное правило:** Представление должно быть **семантически завершенным** — представлять собой логическую сущность (например, "активные клиенты", "ежемесячные продажи"), а не просто техническую группировку столбцов. Правильно спроектированные представления становятся ценным активом в долгосрочной поддержке и развитии системы.