### Понятие триггера. Таблицы inserted и deleted

### **Часть 1. Понятие и назначение триггеров**

**Триггер (Trigger)** — это специальный тип хранимой процедуры, которая **автоматически выполняется** в ответ на определенное событие в базе данных (изменение данных или определение объектов).

**Ключевая особенность:** Триггеры срабатывают **неявно**, без явного вызова пользователем или приложением. Они являются частью транзакции, вызвавшей событие.

#### **Классификация триггеров:**

**1. По типу события:**
*   **DML-триггеры (Data Manipulation Language):** Реагируют на события `INSERT`, `UPDATE`, `DELETE`.
*   **DDL-триггеры (Data Definition Language):** Реагируют на события `CREATE`, `ALTER`, `DROP` (серверные или на уровне базы данных).
*   **LOGON-триггеры:** Срабатывают при установке соединения с сервером.

**2. По времени срабатывания (для DML-триггеров):**
*   **AFTER-триггер (или FOR-триггер):** Выполняется **после** завершения операции, вызвавшей событие, но **до фиксации транзакции**. Самый распространенный тип.
*   **INSTEAD OF-триггер:** Выполняется **вместо** операции, вызвавшей событие. Позволяет переопределить стандартное поведение команды DML.

**3. По уровню срабатывания:**
*   **Триггер уровня строки (FOR EACH ROW):** Выполняется для **каждой изменяемой строки** отдельно (в SQL Server реализуется через множественные строки в таблицах `inserted`/`deleted`).
*   **Триггер уровня оператора (FOR EACH STATEMENT):** Выполняется **один раз для всей операци**и, независимо от количества затронутых строк (стандартное поведение в SQL Server).

---

### **Часть 2. Логические таблицы `inserted` и `deleted`**

Это **ключевые объекты** для работы с данными внутри DML-триггеров. Они представляют собой **специальные таблицы в памяти**, доступные только в контексте выполнения триггера.

#### **Структура и назначение:**

| Таблица | Когда существует | Что содержит |
| :--- | :--- | :--- |
| **`inserted`** | Для операций `INSERT` и `UPDATE` | **Новые значения** строк. <br> • При `INSERT` — все вставленные строки. <br> • При `UPDATE` — новые (измененные) значения строк. |
| **`deleted`** | Для операций `DELETE` и `UPDATE` | **Старые значения** строк. <br> • При `DELETE` — все удаленные строки. <br> • При `UPDATE` — старые (до изменения) значения строк. |

#### **Важные особенности:**

1.  **Виртуальность:** Эти таблицы физически **не создаются** на диске. Они существуют только в оперативной памяти на время выполнения триггера.
2.  **Структура:** Имеют **точно такую же структуру** (столбцы, типы данных), как таблица, на которой определен триггер.
3.  **Доступ:** Доступны **только внутри триггера**, вызванного соответствующим событием.
4.  **Для операции `UPDATE`:** Существуют **обе** таблицы одновременно:
    *   `deleted` — старые значения (до обновления)
    *   `inserted` — новые значения (после обновления)
    *   Количество строк в обеих таблицах **одинаково** (одна строка в `deleted` соответствует одной строке в `inserted`).
5.  **Время жизни:** Существуют только на время выполнения триггера и его транзакции.

#### **Графическое представление:**

```
Операция: INSERT INTO Employees VALUES (...)
┌─────────────────────────────────────┐
│ Таблица inserted (в памяти триггера) │
│ - содержит 1 строку (новые данные)  │
└─────────────────────────────────────┘

Операция: DELETE FROM Employees WHERE id = 5
┌─────────────────────────────────────┐
│ Таблица deleted (в памяти триггера) │
│ - содержит 1 строку (старые данные) │
└─────────────────────────────────────┘

Операция: UPDATE Employees SET Salary = 1000 WHERE id = 5
┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐
│ Таблица deleted (в памяти триггера) │  │ Таблица inserted (в памяти триггера) │
│ - содержит 1 строку (Salary=500)    │  │ - содержит 1 строку (Salary=1000)   │
└─────────────────────────────────────┘  └─────────────────────────────────────┘
              Старое значение                          Новое значение
```

---

### **Часть 3. Создание DML-триггеров в T-SQL**

#### **3.1. Синтаксис создания триггера**

```sql
CREATE [ OR ALTER ] TRIGGER [schema_name.]trigger_name 
ON { table_name | view_name }  -- Триггер привязывается к таблице или представлению
[ WITH { ENCRYPTION | EXECUTE AS clause } ]  -- Дополнительные опции
{ FOR | AFTER | INSTEAD OF }  -- Время срабатывания
{ [INSERT] [,] [UPDATE] [,] [DELETE] }  -- События
AS
BEGIN
    -- Тело триггера (T-SQL код)
    -- Работа с таблицами inserted/deleted
END;
```

#### **3.2. Практические примеры**

**Пример 1: AFTER-триггер для аудита изменений (классический пример)**

```sql
-- 1. Создаем таблицу для аудита
CREATE TABLE dbo.EmployeeAudit
(
    AuditID INT IDENTITY PRIMARY KEY,
    EmployeeID INT NOT NULL,
    ChangeType CHAR(1) NOT NULL, -- 'I'=Insert, 'U'=Update, 'D'=Delete
    ChangeDate DATETIME NOT NULL DEFAULT GETDATE(),
    OldSalary DECIMAL(10,2) NULL,
    NewSalary DECIMAL(10,2) NULL,
    ChangedBy NVARCHAR(128) NOT NULL DEFAULT SUSER_SNAME()
);

-- 2. Создаем триггер на таблицу Employees
CREATE TRIGGER dbo.trg_Employee_Audit
ON dbo.Employees
AFTER INSERT, UPDATE, DELETE  -- Триггер на все три операции
AS
BEGIN
    SET NOCOUNT ON;  -- Отключаем сообщение о количестве обработанных строк
    
    -- Аудит для INSERT
    IF EXISTS (SELECT * FROM inserted) AND NOT EXISTS (SELECT * FROM deleted)
    BEGIN
        INSERT INTO dbo.EmployeeAudit (EmployeeID, ChangeType, NewSalary)
        SELECT 
            i.EmployeeID,
            'I',  -- Insert
            i.Salary
        FROM inserted i;
    END
    
    -- Аудит для DELETE
    IF EXISTS (SELECT * FROM deleted) AND NOT EXISTS (SELECT * FROM inserted)
    BEGIN
        INSERT INTO dbo.EmployeeAudit (EmployeeID, ChangeType, OldSalary)
        SELECT 
            d.EmployeeID,
            'D',  -- Delete
            d.Salary
        FROM deleted d;
    END
    
    -- Аудит для UPDATE (сравниваем старые и новые значения)
    IF EXISTS (SELECT * FROM inserted) AND EXISTS (SELECT * FROM deleted)
    BEGIN
        INSERT INTO dbo.EmployeeAudit (EmployeeID, ChangeType, OldSalary, NewSalary)
        SELECT 
            i.EmployeeID,
            'U',  -- Update
            d.Salary,  -- Old salary
            i.Salary   -- New salary
        FROM inserted i
        INNER JOIN deleted d ON i.EmployeeID = d.EmployeeID
        WHERE i.Salary <> d.Salary OR (i.Salary IS NULL AND d.Salary IS NOT NULL)
            OR (i.Salary IS NOT NULL AND d.Salary IS NULL);
    END
END;
GO
```

**Пример 2: INSTEAD OF-триггер для реализации сложной бизнес-логики**

```sql
-- Создаем представление, объединяющее данные из двух таблиц
CREATE VIEW dbo.vw_OrderDetailsExtended
AS
SELECT 
    o.OrderID, o.CustomerID, o.OrderDate,
    od.ProductID, od.Quantity, od.UnitPrice,
    p.ProductName
FROM dbo.Orders o
JOIN dbo.[Order Details] od ON o.OrderID = od.OrderID
JOIN dbo.Products p ON od.ProductID = p.ProductID;

-- Создаем INSTEAD OF триггер для вставки через представление
CREATE TRIGGER dbo.trg_vw_OrderDetailsExtended_Insert
ON dbo.vw_OrderDetailsExtended
INSTEAD OF INSERT
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Вставляем в основную таблицу Orders (если заказа еще нет)
    INSERT INTO dbo.Orders (OrderID, CustomerID, OrderDate)
    SELECT DISTINCT i.OrderID, i.CustomerID, i.OrderDate
    FROM inserted i
    WHERE NOT EXISTS (SELECT 1 FROM dbo.Orders o WHERE o.OrderID = i.OrderID);
    
    -- Вставляем в таблицу Order Details
    INSERT INTO dbo.[Order Details] (OrderID, ProductID, Quantity, UnitPrice)
    SELECT i.OrderID, i.ProductID, i.Quantity, i.UnitPrice
    FROM inserted i;
END;
GO

-- Теперь можно вставлять данные через представление
INSERT INTO dbo.vw_OrderDetailsExtended 
    (OrderID, CustomerID, OrderDate, ProductID, Quantity, UnitPrice, ProductName)
VALUES (12345, 'ALFKI', GETDATE(), 42, 10, 19.99, 'Тестовый товар');
```

**Пример 3: Триггер с проверкой бизнес-правила**

```sql
CREATE TRIGGER dbo.trg_Order_CheckQuantity
ON dbo.[Order Details]
AFTER INSERT, UPDATE
AS
BEGIN
    IF @@ROWCOUNT = 0 RETURN;  -- Если строк не затронуто, выходим
    
    -- Проверяем, не превышает ли заказанное количество доступное на складе
    IF EXISTS (
        SELECT 1
        FROM inserted i
        JOIN dbo.Products p ON i.ProductID = p.ProductID
        WHERE i.Quantity > p.UnitsInStock
    )
    BEGIN
        -- Откатываем транзакцию и выдаем ошибку
        ROLLBACK TRANSACTION;
        THROW 51000, 
            'Заказанное количество превышает доступное на складе!', 
            1;
    END
END;
GO
```

---

### **Часть 4. Практические сценарии, преимущества и недостатки**

#### **Типичные сценарии использования триггеров:**

1.  **Аудит и журналирование:** Отслеживание изменений данных (кто, когда, что изменил).
2.  **Обеспечение сложной целостности данных:** Проверка бизнес-правил, которые невозможно реализовать через `CHECK`-ограничения.
3.  **Каскадные операции:** Автоматическое обновление связанных данных (например, обновление суммарного поля при изменении деталей).
4.  **Обход ограничений представлений:** Создание обновляемых представлений через `INSTEAD OF` триггеры.
5.  **Реализация мягкого удаления (Soft Delete):** Замена физического удаления на установку флага `IsDeleted`.

#### **Преимущества триггеров:**

1.  **Централизация логики:** Бизнес-правила хранятся в одном месте (БД), а не дублируются во всех приложениях.
2.  **Автоматическое выполнение:** Не требуют явного вызова, гарантированно срабатывают.
3.  **Транзакционность:** Являются частью транзакции, можно откатить всю операцию при ошибке.
4.  **Реактивность:** Мгновенная реакция на изменения данных.

#### **Критические недостатки и риски:**

1.  **Скрытая логика (Неявное поведение):** Усложняют понимание системы. Разработчик может не знать о существовании триггера.
2.  **Проблемы с производительностью:** Каждый DML-запрос вызывает дополнительную нагрузку. Особенно опасны триггеры с медленными операциями или рекурсивные триггеры.
3.  **Сложность отладки:** Труднее отследить ошибки, возникающие в триггерах.
4.  **Риск бесконечной рекурсии:** Триггер может вызывать сам себя (прямо или через цепочку других триггеров).
5.  **Блокировки:** Могут удерживать блокировки дольше, увеличивая конкуренцию.
6.  **Сложность миграции:** Привязка к конкретной СУБД.

#### **Современные альтернативы триггерам:**

| **Сценарий** | **Альтернатива триггерам** |
| :--- | :--- |
| **Аудит изменений** | **Система темпоральных таблиц (Temporal Tables)** — встроенная в SQL Server 2016+. Автоматическое ведение истории. |
| **Вычисляемые столбцы** | **Сохраненные вычисляемые столбцы (PERSISTED)** или **индексированные представления**. |
| **Каскадные обновления** | **Встроенные каскадные операции** (`ON UPDATE CASCADE`) в ограничениях внешнего ключа. |
| **Сложная валидация** | **Хранимые процедуры** как единственный интерфейс для изменения данных. |
| **Очереди и обработка событий** | **Service Broker** или **Azure Service Bus** для асинхронной обработки. |

---

### **3. Заключение и лучшие практики**

**Триггеры — это "атомное оружие" в арсенале разработчика БД.** Мощный, но опасный инструмент.

**Когда использовать триггеры:**
1.  Для **непреложных бизнес-правил**, которые должны выполняться всегда.
2.  Для **сквозных функций** (аудит, логирование), не связанных напрямую с бизнес-логикой.
3.  Когда **нет технической возможности** изменить клиентский код.

**Лучшие практики создания триггеров:**

1.  **Пишите быстрые триггеры:** Избегайте сложных запросов, курсоров, операций с большими наборами данных.
2.  **Обрабатывайте множественные строки:** Помните, что триггер срабатывает для всей операции, используйте `inserted`/`deleted` как наборы.
3.  **Избегайте рекурсии:** Используйте `RECURSIVE_TRIGGERS` настройку и проверяйте условия.
4.  **Не выполняйте собственные DML-операции** на таблице, на которой сработал триггер (риск рекурсии).
5.  **Всегда устанавливайте `SET NOCOUNT ON`** в начале триггера.
6.  **Явно указывайте схему:** `dbo.trg_Name`, а не просто `trg_Name`.
7.  **Документируйте триггеры:** Используйте расширенные свойства для описания назначения.
8.  **Тестируйте с разным объемом данных:** Убедитесь, что триггер работает корректно при вставке 1, 1000 и 0 строк.

**Финальный вывод:** Современная тенденция — **минимизация использования триггеров** в пользу декларативных ограничений, временных таблиц и явных хранимых процедур. Однако для определенных классов задач (особенно аудита) триггеры остаются наиболее элегантным и эффективным решением.