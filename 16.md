### Функции пользователя. Системные функции

### **Часть 1. Пользовательские функции (User-Defined Functions, UDF)**

**Функция пользователя** — это программный модуль, который принимает параметры, выполняет действия и возвращает результат. В отличие от процедур, функции **всегда возвращают значение** и могут использоваться в SQL-выражениях.

#### **Классификация пользовательских функций:**

| Тип | Возвращаемое значение | Можно ли использовать в SELECT? | Модификация данных |
| :--- | :--- | :--- | :--- |
| **Скалярная функция** | Одно значение любого типа | Да | Нет (только `SELECT` без DML) |
| **Встроенная табличная функция (ITVF)** | Таблица (одна инструкция `RETURN`) | Да (в `FROM`) | Нет |
| **Многооператорная табличная функция (MSTVF)** | Таблица (сложная логика в теле) | Да (в `FROM`) | Нет |

---

#### **1.1. Скалярные функции (Scalar Functions)**

Возвращают одно значение заданного типа данных.

**Синтаксис:**
```sql
CREATE [ OR ALTER ] FUNCTION [schema_name.]function_name 
(
    [ @parameter1 [ AS ] data_type [ = default ] ]
    [ , ... ]
)
RETURNS return_data_type
[ WITH { ENCRYPTION | SCHEMABINDING | RETURNS NULL ON NULL INPUT | CALLED ON NULL INPUT } ]
[ AS ]
BEGIN
    -- Тело функции (логика)
    RETURN scalar_expression;
END;
```

**Пример 1: Функция для форматирования даты**
```sql
CREATE FUNCTION dbo.fn_FormatDate
(
    @InputDate DATETIME,
    @FormatType CHAR(1) = 'S' -- 'S' - short, 'L' - long
)
RETURNS NVARCHAR(50)
WITH SCHEMABINDING  -- Привязка к зависимым объектам
AS
BEGIN
    DECLARE @Result NVARCHAR(50);
    
    IF @InputDate IS NULL
        RETURN NULL;
    
    IF @FormatType = 'S'  -- Короткий формат: ДД.ММ.ГГГГ
        SET @Result = FORMAT(@InputDate, 'dd.MM.yyyy', 'ru-RU');
    ELSE IF @FormatType = 'L'  -- Длинный: "15 января 2024 г."
        SET @Result = FORMAT(@InputDate, 'd MMMM yyyy г.', 'ru-RU');
    ELSE
        SET @Result = CONVERT(NVARCHAR(50), @InputDate, 121); -- ISO
        
    RETURN @Result;
END;
GO

-- Использование
SELECT 
    OrderID,
    dbo.fn_FormatDate(OrderDate, 'S') AS ShortDate,
    dbo.fn_FormatDate(OrderDate, 'L') AS LongDate
FROM Orders;
```

**Пример 2: Функция для вычисления НДС**
```sql
CREATE FUNCTION dbo.fn_CalculateVAT
(
    @Amount DECIMAL(18,2),
    @VATRate DECIMAL(5,2) = 20.00
)
RETURNS DECIMAL(18,2)
AS
BEGIN
    RETURN @Amount * @VATRate / 100;
END;
GO

-- Использование в запросе
SELECT 
    ProductName,
    Price,
    dbo.fn_CalculateVAT(Price, 20) AS VATAmount,
    Price + dbo.fn_CalculateVAT(Price, 20) AS PriceWithVAT
FROM Products;
```

---

#### **1.2. Встроенные табличные функции (Inline Table-Valued Functions, ITVF)**

Возвращают таблицу как результат одного оператора `SELECT`. **Наиболее производительный** тип табличных функций.

**Синтаксис:**
```sql
CREATE FUNCTION [schema_name.]function_name 
(
    [ @parameter1 [ AS ] data_type [ = default ] ]
    [ , ... ]
)
RETURNS TABLE
[ WITH { ENCRYPTION | SCHEMABINDING } ]
[ AS ]
RETURN ( select_statement );
```

**Пример: Функция для получения заказов за период**
```sql
CREATE FUNCTION dbo.fn_GetOrdersByPeriod
(
    @StartDate DATE,
    @EndDate DATE,
    @CustomerID INT = NULL
)
RETURNS TABLE
WITH SCHEMABINDING
AS
RETURN
(
    SELECT 
        o.OrderID,
        o.OrderDate,
        c.CompanyName,
        SUM(od.Quantity * od.UnitPrice) AS TotalAmount,
        COUNT(od.OrderID) AS ItemsCount
    FROM dbo.Orders o
    JOIN dbo.Customers c ON o.CustomerID = c.CustomerID
    JOIN dbo.[Order Details] od ON o.OrderID = od.OrderID
    WHERE o.OrderDate BETWEEN @StartDate AND @EndDate
        AND (@CustomerID IS NULL OR o.CustomerID = @CustomerID)
    GROUP BY o.OrderID, o.OrderDate, c.CompanyName
);
GO

-- Использование (как обычная таблица)
SELECT * FROM dbo.fn_GetOrdersByPeriod('2024-01-01', '2024-12-31', NULL);
SELECT * FROM dbo.fn_GetOrdersByPeriod('2024-01-01', '2024-12-31', 12345);

-- Использование в JOIN
SELECT 
    c.CompanyName,
    f.TotalAmount
FROM Customers c
CROSS APPLY dbo.fn_GetOrdersByPeriod('2024-01-01', '2024-12-31', c.CustomerID) f;
```

---

#### **1.3. Многооператорные табличные функции (Multi-Statement Table-Valued Functions, MSTVF)**

Возвращают таблицу, но могут содержать сложную логику с временными таблицами, циклами и т.д.

**Синтаксис:**
```sql
CREATE FUNCTION [schema_name.]function_name 
(
    [ @parameter1 [ AS ] data_type [ = default ] ]
    [ , ... ]
)
RETURNS @return_variable TABLE 
(
    column1 data_type [ constraints ],
    column2 data_type [ constraints ],
    ...
)
[ WITH { ENCRYPTION | SCHEMABINDING } ]
[ AS ]
BEGIN
    -- Сложная логика с операторами T-SQL
    INSERT INTO @return_variable
    SELECT ... ;
    
    RETURN;
END;
```

**Пример: Функция для разбора строки в таблицу**
```sql
CREATE FUNCTION dbo.fn_SplitString
(
    @InputString NVARCHAR(MAX),
    @Delimiter CHAR(1) = ','
)
RETURNS @ResultTable TABLE 
(
    ItemID INT IDENTITY(1,1) PRIMARY KEY,
    ItemValue NVARCHAR(1000)
)
AS
BEGIN
    DECLARE @StartIndex INT = 1;
    DECLARE @EndIndex INT;
    DECLARE @Item NVARCHAR(1000);
    
    IF @InputString IS NULL 
        RETURN;
        
    -- Удаление начальных и конечных пробелов
    SET @InputString = LTRIM(RTRIM(@InputString));
    
    WHILE @StartIndex <= LEN(@InputString)
    BEGIN
        SET @EndIndex = CHARINDEX(@Delimiter, @InputString, @StartIndex);
        
        IF @EndIndex = 0
            SET @EndIndex = LEN(@InputString) + 1;
            
        SET @Item = SUBSTRING(@InputString, @StartIndex, @EndIndex - @StartIndex);
        SET @Item = LTRIM(RTRIM(@Item));
        
        IF @Item <> ''
            INSERT INTO @ResultTable (ItemValue) VALUES (@Item);
            
        SET @StartIndex = @EndIndex + 1;
    END
    
    RETURN;
END;
GO

-- Использование
SELECT * FROM dbo.fn_SplitString('apple,banana,orange,grape', ',');
```

---

#### **Ограничения пользовательских функций:**

1.  **Запрещены операции DML:** Нельзя выполнять `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE` (кроме временных таблиц).
2.  **Нет побочных эффектов:** Нельзя изменять состояние базы данных.
3.  **Нет динамического SQL:** Нельзя использовать `EXEC`, `sp_executesql` (кроме скалярных функций без `WITH SCHEMABINDING`).
4.  **Нет внешних вызовов:** Нельзя вызывать расширенные процедуры, OLE-объекты.
5.  **Нет `TRY...CATCH`:** Обработка ошибок ограничена.

---

### **Часть 2. Системные функции**

**Системные функции** — это встроенные функции SQL Server для выполнения различных операций. Они делятся на несколько категорий.

#### **2.1. Скалярные системные функции**

| Категория | Функции | Описание |
| :--- | :--- | :--- |
| **Строковые** | `LEN()`, `LEFT()`, `RIGHT()`, `SUBSTRING()`, `REPLACE()`, `CHARINDEX()`, `PATINDEX()`, `FORMAT()` | Работа со строками |
| **Математические** | `ABS()`, `ROUND()`, `CEILING()`, `FLOOR()`, `RAND()`, `POWER()`, `SQRT()` | Математические вычисления |
| **Дата и время** | `GETDATE()`, `DATEADD()`, `DATEDIFF()`, `DATEPART()`, `DATENAME()`, `SYSDATETIME()` | Работа с датами |
| **Преобразование** | `CAST()`, `CONVERT()`, `TRY_CAST()`, `TRY_CONVERT()`, `PARSE()` | Преобразование типов |
| **Логические** | `ISNULL()`, `COALESCE()`, `NULLIF()`, `IIF()`, `CHOOSE()` | Работа с NULL и условная логика |
| **Метаданные** | `OBJECT_ID()`, `OBJECT_NAME()`, `COL_LENGTH()`, `DB_NAME()`, `USER_NAME()` | Информация об объектах |

**Примеры использования:**
```sql
-- Работа с датами
SELECT 
    GETDATE() AS CurrentDateTime,
    DATEADD(DAY, 7, GETDATE()) AS NextWeek,
    DATEDIFF(YEAR, '1990-01-01', GETDATE()) AS YearsPassed;

-- Работа со строками
SELECT 
    UPPER('hello world') AS UpperCase,
    REPLACE('foo bar baz', 'bar', 'qux') AS Replaced,
    FORMAT(1234567.89, 'C', 'ru-RU') AS FormattedCurrency;

-- Работа с NULL
SELECT 
    ISNULL(NULL, 'Default Value') AS IsNullResult,
    COALESCE(NULL, NULL, 'First Non-Null') AS CoalesceResult,
    IIF(1 > 0, 'True', 'False') AS IIfResult;
```

#### **2.2. Агрегатные функции**

| Функция | Описание |
| :--- | :--- |
| `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()` | Базовые агрегаты |
| `STRING_AGG()` | Конкатенация строк с разделителем |
| `STDEV()`, `VAR()` | Статистические функции |
| `CHECKSUM_AGG()` | Контрольная сумма |

**Пример:**
```sql
SELECT 
    DepartmentID,
    COUNT(*) AS EmployeeCount,
    AVG(Salary) AS AvgSalary,
    STRING_AGG(LastName, ', ') WITHIN GROUP (ORDER BY LastName) AS EmployeesList
FROM Employees
GROUP BY DepartmentID;
```

#### **2.3. Оконные функции (Window Functions)**

| Категория | Функции |
| :--- | :--- |
| **Ранжирующие** | `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE()` |
| **Агрегатные** | `SUM() OVER()`, `AVG() OVER()`, `COUNT() OVER()` |
| **Смещения** | `LAG()`, `LEAD()`, `FIRST_VALUE()`, `LAST_VALUE()` |

**Пример:**
```sql
SELECT 
    EmployeeID,
    LastName,
    Salary,
    DepartmentID,
    ROW_NUMBER() OVER(PARTITION BY DepartmentID ORDER BY Salary DESC) AS DeptRank,
    AVG(Salary) OVER(PARTITION BY DepartmentID) AS AvgDeptSalary,
    LAG(Salary, 1) OVER(ORDER BY Salary) AS PrevSalary
FROM Employees;
```

#### **2.4. Системные функции для управления**

| Функция | Назначение |
| :--- | :--- |
| `@@IDENTITY`, `SCOPE_IDENTITY()` | Последнее значение IDENTITY |
| `@@ROWCOUNT` | Количество обработанных строк |
| `@@ERROR` | Код последней ошибки |
| `SUSER_SNAME()`, `USER_NAME()` | Имена пользователей |
| `HOST_NAME()` | Имя компьютера |

---

### **Часть 3. Сравнительный анализ функций и хранимых процедур**

| Критерий | Функция | Хранимая процедура |
| :--- | :--- | :--- |
| **Возвращаемое значение** | Обязательно одно (скалярное или табличное) | Не обязательно, может быть 0 или много |
| **Использование в SELECT** | Да (в любом выражении) | Нет (только `EXEC`) |
| **Изменение данных** | Запрещено (только чтение) | Разрешено (любые DML) |
| **Вывод параметров** | Нет (`OUTPUT` параметров) | Есть (`OUTPUT` параметры) |
| **План выполнения** | Кэшируется, но может быть менее эффективным (MSTVF) | Кэшируется, обычно оптимальный |
| **Транзакции** | Неявные, нельзя управлять явно | Явные (`BEGIN TRANSACTION` и др.) |
| **Обработка ошибок** | Ограничена (нет `TRY...CATCH`) | Полная (`TRY...CATCH`) |
| **Динамический SQL** | Запрещен или ограничен | Разрешен |
| **Производительность** | ITVF — отлично, MSTVF — может быть плохо | Обычно хорошо |

---

### **Часть 4. Практические сценарии и рекомендации**

#### **Когда использовать функции:**

1.  **Вычисления в запросах:** Сложные вычисления, форматирование.
2.  **Параметризованные представления:** ITVF как альтернатива представлениям с параметрами.
3.  **Разбор данных:** Преобразование структур (XML, JSON, строк) в табличный вид.
4.  **Повторяющаяся логика:** Часто используемые вычисления в разных запросах.
5.  **Слой абстракции:** Сокрытие сложных вычислений.

#### **Когда НЕ использовать функции:**

1.  **Для операций с данными:** Используйте хранимые процедуры.
2.  **Для сложной бизнес-логики:** Используйте хранимые процедуры.
3.  **Когда нужны побочные эффекты:** Используйте хранимые процедуры.
4.  **Для MSTVF на больших данных:** Рассмотрите временные таблицы.

#### **Рекомендации по созданию функций:**

1.  **Используйте `WITH SCHEMABINDING`:** Защищает от изменения зависимых объектов.
2.  **Избегайте MSTVF для больших наборов:** Они материализуются в `tempdb` и не имеют статистики.
3.  **Именуйте осмысленно:** `fn_CalculateTax`, `ufn_GetOrders`.
4.  **Документируйте параметры:** Используйте расширенные свойства.
5.  **Тестируйте производительность:** Сравнивайте с эквивалентными запросами.

#### **Пример плохой и хорошей практики:**

```sql
-- ПЛОХО: MSTVF для большого набора данных
CREATE FUNCTION dbo.fn_GetLargeDataset()
RETURNS @t TABLE (ID INT, Value NVARCHAR(100))
AS
BEGIN
    INSERT INTO @t
    SELECT ID, Value FROM HugeTable WHERE Condition = 1;
    RETURN;
END;

-- ХОРОШО: Вместо этого использовать ITVF или представление
CREATE FUNCTION dbo.fn_GetLargeDataset()
RETURNS TABLE
AS
RETURN
(
    SELECT ID, Value FROM HugeTable WHERE Condition = 1
);
```

---

### **3. Заключение**

**Функции в SQL Server — мощный инструмент для:**
- **Модуляризации** кода
- **Упрощения** сложных запросов
- **Обеспечения** повторного использования логики

**Ключевые выводы:**
1.  **Предпочитайте ITVF** MSTVF для лучшей производительности.
2.  **Системные функции** — ваш лучший друг для стандартных операций.
3.  **Функции vs процедуры** — это разные инструменты для разных задач.
4.  **Всегда проверяйте** влияние функций на производительность запросов.

**Помните:** Неправильное использование функций (особенно MSTVF) — одна из частых причин проблем с производительностью. Используйте их осознанно и тестируйте на реальных объемах данных.