### Классификация СУБД. Критерии выбора СУБД.

### **Часть 1. Классификация СУБД**

Современные СУБД можно классифицировать по нескольким независимым осям, что отражает их специализацию и архитектурные особенности.

**I. По модели данных (наиболее фундаментальная классификация)**
1.  **Реляционные (RDBMS):** Данные в таблицах со строгой схемой, связи через ключи. Используют SQL (MySQL, PostgreSQL, Oracle, MS SQL Server).
2.  **Нереляционные (NoSQL):**
    *   **Документные:** Данные как JSON/XML-документы (MongoDB, Couchbase).
    *   **Столбцовые (Column-family):** Данные хранятся по столбцам, а не строкам (Cassandra, HBase, ClickHouse*).
    *   **Ключ-значение (Key-Value):** Простой доступ по уникальному ключу (Redis, DynamoDB, etcd).
    *   **Графовые:** Сущности как узлы, связи — рёбра (Neo4j, Amazon Neptune).
3.  **Многомодельные:** Поддерживают несколько моделей в одном ядре (Azure Cosmos DB, ArangoDB, PostgreSQL (с расширениями JSONB, graph)).
4.  **NewSQL:** Сочетают горизонтальную масштабируемость NoSQL с ACID-гарантиями и SQL-интерфейсом (CockroachDB, Google Spanner, YugabyteDB).

**II. По способу хранения и обработки**
*   **Дисковые:** Основное хранилище — HDD/SSD (большинство традиционных СУБД).
*   **Оперативные (In-Memory):** Все данные в RAM для максимальной скорости (Redis, Memcached, SAP HANA, Tarantool). Могут иметь персистентность на диск.

**III. По архитектуре распределения**
*   **Локальные (Single-instance):** Один сервер (подходит для малых проектов).
*   **Распределенные (Distributed):**
    *   **Шардирование (горизонтальное партиционирование):** Данные разделены между узлами.
    *   **Репликация:** Копии данных на нескольких узлах (мастер-слейв, мастер-мастер).
    *   **Гибридные архитектуры.**

**IV. По типу обработки рабочей нагрузки (OLTP vs OLAP)**
*   **OLTP (Online Transaction Processing):** Много коротких операций записи/чтения, работа с актуальными данными, высокий параллелизм. *Примеры:* PostgreSQL, Oracle, MongoDB.
*   **OLAP (Online Analytical Processing):** Сложные read-only запросы для анализа больших объемов исторических данных. *Примеры:* ClickHouse, Amazon Redshift, Google BigQuery.
*   **HTAP (Hybrid Transactional/Analytical Processing):** Поддержка обоих типов нагрузки в одной системе (ClickHouse, некоторые режимы Oracle, специальные архитектуры).

**V. По модели лицензирования и развертывания**
*   **Проприетарные (коммерческие):** Oracle Database, Microsoft SQL Server, IBM Db2.
*   **Открытые (Open Source):** PostgreSQL, MySQL, MongoDB (с коммерческой лицензией для некоторых версий), Redis.
*   **Управляемые облачные сервисы (DBaaS):** Полностью сервис от облачного провайдера (Amazon RDS/Aurora, Google Cloud SQL, Azure Cosmos DB, Managed Cassandra).

---

### **Часть 2. Критерии выбора СУБД**

Выбор СУБД — это поиск баланса между часто противоречивыми требованиями. Решение принимается на основе анализа следующих групп критериев.

**I. Бизнес-требования и контекст проекта**
*   **Бюджет:** Лицензионные/подписные costs (CAPEX/OPEX), стоимость администрирования и разработки.
*   **Сроки выхода на рынок (Time-to-Market):** Готовность решения, простота разработки, зрелость инструментов и ORM.
*   **Навыки команды:** Наличие экспертизы по конкретной СУБД.
*   **Стратегия вендора/экосистема:** Привязка к конкретному облачному провайдеру, долгосрочная поддержка, активность сообщества (для Open Source).

**II. Технические требования к данным**
*   **Модель данных и ее изменчивость:**
    *   **Структурированные, строгие связи** → Реляционные СУБД.
    *   **Гибкая, часто меняющаяся схема, иерархические данные** → Документные СУБД.
    *   **Сложные связи, графовые зависимости** → Графовые СУБД.
    *   **Широкие таблицы, аналитика по столбцам** → Столбцовые СУБД.
*   **Объем данных и трафик операций:** Текущий и прогнозируемый. Определяет необходимость в горизонтальном масштабировании (шардировании).
*   **Требования к согласованности (CAP-теорема):**
    *   **Строгая согласованность (CP-системы)** необходим для финансовых транзакций (RDBMS, NewSQL).
    *   **Высокая доступность и eventual consistency (AP-системы)** допустимы для социальных лент, кэшей (Cassandra, DynamoDB).
*   **Надежность и отказоустойчивость:** Требуемый уровень RPO/RTO, механизмы репликации и бэкапа.

**III. Требования к производительности**
*   **Характер нагрузки:** OLTP (высокий IOPS, низкая задержка) vs OLAP (высокая пропускная способность для сложных запросов).
*   **Паттерны доступа:** Преобладание чтения или записи, необходимость полнотекстового поиска, геозапросов.
*   **Задержка (Latency) и пропускная способность (Throughput):** Критичные значения для приложения.

**IV. Операционные требования (DevOps)**
*   **Сложность администрирования:** Требования к квалификации DBA, наличие автоматизации управления.
*   **Масштабируемость:**
    *   **Вертикальное (scale-up):** Упрощает администрирование, но имеет предел и дорого.
    *   **Горизонтальное (scale-out):** Сложнее в реализации, но потенциально безгранично. Естественно для многих NoSQL и NewSQL систем.
*   **Интеграция с инфраструктурой:** Совместимость с оркестраторами (Kubernetes), системами мониторинга (Prometheus), CI/CD.

#### **3. Практический вывод и компромиссы**

Не существует «лучшей СУБД для всех задач». Выбор — это **осознанный компромисс**.

*   **Масштабируемость vs ACID-гарантии:** Легко масштабируемые NoSQL-системы часто ослабляют транзакционные гарантии.
*   **Гибкость схемы vs целостность данных:** Документные БД дают гибкость, но переносят ответственность за целостность на приложение.
*   **Производительность записи vs производительность чтения:** Оптимизация под один паттерн часто ухудшает другой (например, столбцовые хранилища).
*   **Простота разработки vs контроль:** Управляемые облачные сервисы (DBaaS) снимают операционную нагрузку, но ограничивают в низкоуровневой настройке.

**Рекомендуемый подход:**
1.  Начинать с анализа **модели данных и бизнес-требований**.
2.  Определить **критически важные параметры** (например, согласованность > задержка).
3.  Рассматривать **полиглотную архитектуру** (использование разных СУБД для разных микросервисов/задач).
4.  Прототипировать и проводить нагрузочное тестирование на 2-3 наиболее подходящих кандидатах.