### Временные базы данных и управление темпоральными данными

### **Часть 1. Временные базы данных**

#### **1.1. Типы временных объектов в SQL Server**

| Тип | Время жизни | Хранение | Видимость | Назначение |
| :--- | :--- | :--- | :--- | :--- |
| **Временные таблицы** (`#Temp`) | Сессия/пакет | `tempdb` | Только создавшая сессия | Промежуточные вычисления, кэширование |
| **Глобальные временные таблицы** (`##Temp`) | До последней сессии | `tempdb` | Все сессии | Общие промежуточные данные |
| **Табличные переменные** (`@Table`) | Пакет/функция | `tempdb` (часто в памяти) | Текущий пакет | Маленькие наборы, параметры функций |
| **Временные таблицы в памяти** | Сессия | RAM (`tempdb`) | Только создавшая сессия | Высокопроизводительные операции |

#### **1.2. Создание и использование временных таблиц**

```sql
-- 1. Локальная временная таблица (префикс #)
CREATE TABLE #TempEmployees (
    EmployeeID INT PRIMARY KEY,
    LastName NVARCHAR(50),
    HireDate DATE,
    INDEX IX_TempEmployees_LastName (LastName)
);

-- Вставка данных
INSERT INTO #TempEmployees
SELECT EmployeeID, LastName, HireDate
FROM dbo.Employees
WHERE DepartmentID = 5;

-- Использование
SELECT * FROM #TempEmployees;

-- Автоматически удаляется при завершении сессии
-- или можно удалить явно
DROP TABLE IF EXISTS #TempEmployees;

-- 2. Глобальная временная таблица (префикс ##)
CREATE TABLE ##GlobalTemp (
    SessionID INT,
    DataValue NVARCHAR(100)
);

-- Доступна из всех сессий
-- Удаляется, когда все сессии, ссылающиеся на нее, закрыты

-- 3. Табличная переменная
DECLARE @EmployeeTable TABLE (
    EmployeeID INT PRIMARY KEY,
    LastName NVARCHAR(50) INDEX IX_LastName,
    HireDate DATE
);

-- Вставка
INSERT INTO @EmployeeTable
VALUES (1, 'Smith', '2020-01-15');

-- Использование
SELECT * FROM @EmployeeTable;

-- Автоматически удаляется при завершении пакета
```

#### **1.3. Особенности производительности**

```sql
-- Сравнение временных таблиц и табличных переменных
-- ВРЕМЕННАЯ ТАБЛИЦА:
-- + Есть статистика (лучше для больших наборов)
-- + Можно создавать индексы после создания
-- + Поддерживает TRUNCATE
-- - Блокировки и логирование в tempdb

-- ТАБЛИЧНАЯ ПЕРЕМЕННАЯ:
-- + Минимальное логирование
-- + Нет блокировок (оптимистическая конкурентность)
-- - Нет статистики (плохо для больших наборов)
-- - Ограниченные индексы (только при объявлении)

-- Рекомендации:
-- < 100 строк → табличная переменная
-- > 1000 строк → временная таблица
-- 100-1000 строк → тестировать оба варианта
```

#### **1.4. База данных TempDB - системный ресурс**

**Назначение TempDB:**
- Временные таблицы и табличные переменные
- Хранение промежуточных результатов сортировки (worktables)
- Хранение версий строк (для MVCC, SNAPSHOT изоляции)
- Хранение внутренних объектов (курсоры, хэш-таблицы)

**Оптимизация TempDB:**
```sql
-- Рекомендуемая настройка для высокой нагрузки
-- 1. Разделение на несколько файлов (по числу ядер CPU, но не более 8)
ALTER DATABASE tempdb 
ADD FILE (
    NAME = tempdev2, 
    FILENAME = 'D:\Data\tempdb2.ndf', 
    SIZE = 8192MB, 
    FILEGROWTH = 256MB
);

-- 2. Одинаковый размер и авторост для всех файлов
-- 3. Размещение на быстрых SSD
-- 4. Отключение автосжатия

-- Мониторинг TempDB
SELECT 
    SUM(user_object_reserved_page_count) * 8 AS UserObjects_KB,
    SUM(internal_object_reserved_page_count) * 8 AS InternalObjects_KB,
    SUM(version_store_reserved_page_count) * 8 AS VersionStore_KB,
    SUM(unallocated_extent_page_count) * 8 AS FreeSpace_KB
FROM sys.dm_db_file_space_usage;

-- Поиск больших временных таблиц
SELECT 
    t.name AS TableName,
    s.row_count,
    (s.reserved_page_count * 8) / 1024.0 AS SizeMB
FROM tempdb.sys.tables t
JOIN tempdb.sys.dm_db_partition_stats s ON t.object_id = s.object_id
WHERE t.name LIKE '#%'
ORDER BY SizeMB DESC;
```

---

### **Часть 2. Системно-версионные темпоральные таблицы**

#### **2.1. Концепция темпоральных таблиц**

**Темпоральная таблица** — это таблица, которая автоматически сохраняет **полную историю изменений** каждой строки с отслеживанием периодов действительности.

**Два типа времени:**
1.  **Системное время (System Time):** Когда данные фактически хранились в БД (автоматическое управление СУБД)
2.  **Время приложения (Application Time):** Когда данные были действительны в предметной области (управляется приложением)

#### **2.2. Создание темпоральных таблиц в SQL Server**

```sql
-- 1. Создание новой темпоральной таблицы
CREATE TABLE dbo.EmployeeHistory
(
    EmployeeID INT NOT NULL PRIMARY KEY,
    LastName NVARCHAR(50) NOT NULL,
    FirstName NVARCHAR(50) NOT NULL,
    Position NVARCHAR(100) NOT NULL,
    Salary DECIMAL(10,2) NOT NULL,
    DepartmentID INT NOT NULL,
    
    -- Обязательные столбцы периода
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START NOT NULL,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END NOT NULL,
    
    -- Определение периода
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime)
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.EmployeeHistory_Archive));

-- 2. Включение системного контроля версий для существующей таблицы
-- Сначала добавить столбцы периода
ALTER TABLE dbo.Employees
ADD 
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START 
        CONSTRAINT DF_Employees_SysStart DEFAULT SYSUTCDATETIME() NOT NULL,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END 
        CONSTRAINT DF_Employees_SysEnd DEFAULT CONVERT(DATETIME2, '9999-12-31 23:59:59.9999999') NOT NULL,
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime);

-- Затем включить системное контролирование версий
ALTER TABLE dbo.Employees
SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.Employees_History));

-- 3. Структура таблицы истории
/*
Текущая таблица (dbo.Employees):
- EmployeeID, LastName, ..., SysStartTime, SysEndTime

Таблица истории (dbo.Employees_History):
- Те же столбцы, что и в текущей таблице
- SysEndTime содержит фактическое время изменения
- PRIMARY KEY не наследуется
- Индексы не наследуются
*/
```

#### **2.3. Особенности темпоральных таблиц**

**Автоматическое управление:**
- При `UPDATE` или `DELETE` текущая строка перемещается в историческую таблицу
- При `INSERT` создается новая строка в текущей таблице
- Столбцы периода заполняются автоматически

**Ограничения:**
- Нельзя использовать `TRUNCATE TABLE`
- Нельзя изменять столбцы периода вручную
- Требуется первичный ключ
- Таблица истории должна находиться в той же БД

---

### **Часть 3. Управление историей данных**

#### **3.1. Запросы к темпоральным данным**

**Специальные предложения для темпоральных запросов:**

```sql
-- 1. AS OF - данные на конкретный момент времени
SELECT * FROM dbo.Employees
FOR SYSTEM_TIME AS OF '2024-06-01 10:00:00';
/*
Возвращает:
- Строки, активные на указанный момент
- Если строка изменилась после указанного времени, 
  возвращается предыдущая версия из истории
*/

-- 2. FROM ... TO - данные в интервале (исключая верхнюю границу)
SELECT * FROM dbo.Employees
FOR SYSTEM_TIME 
    FROM '2024-01-01' TO '2024-12-31';
/*
Возвращает все версии строк, которые были активны 
в указанном интервале [FROM, TO)
*/

-- 3. BETWEEN ... AND - данные в интервале (включая верхнюю границу)
SELECT * FROM dbo.Employees
FOR SYSTEM_TIME 
    BETWEEN '2024-01-01' AND '2024-12-31';
/*
Возвращает все версии строк, которые были активны 
в указанном интервале [BETWEEN, AND]
*/

-- 4. CONTAINED IN - версии, начало и конец которых в интервале
SELECT * FROM dbo.Employees
FOR SYSTEM_TIME 
    CONTAINED IN ('2024-01-01', '2024-12-31');
/*
Возвращает только те версии, которые начали 
и закончили существование в указанном интервале
*/

-- 5. ALL - все строки (текущие + исторические)
SELECT * FROM dbo.Employees
FOR SYSTEM_TIME ALL;
```

#### **3.2. Практические примеры запросов**

```sql
-- Кто был сотрудником на конкретную дату?
SELECT 
    EmployeeID,
    LastName,
    FirstName,
    Position,
    Salary
FROM dbo.Employees
FOR SYSTEM_TIME AS OF '2023-12-31'
WHERE DepartmentID = 5;

-- История изменений зарплаты конкретного сотрудника
SELECT 
    EmployeeID,
    Salary,
    SysStartTime AS ChangeStart,
    SysEndTime AS ChangeEnd
FROM dbo.Employees
FOR SYSTEM_TIME ALL
WHERE EmployeeID = 12345
ORDER BY SysStartTime;

-- Найти сотрудников, которые работали в компании в определенный период
SELECT DISTINCT EmployeeID
FROM dbo.Employees
FOR SYSTEM_TIME 
    FROM '2023-01-01' TO '2023-12-31'
WHERE DepartmentID = 3;

-- Сравнение состояния на две разные даты
WITH CurrentData AS (
    SELECT EmployeeID, Position, Salary
    FROM dbo.Employees
    FOR SYSTEM_TIME AS OF GETDATE()
),
OldData AS (
    SELECT EmployeeID, Position, Salary
    FROM dbo.Employees
    FOR SYSTEM_TIME AS OF DATEADD(YEAR, -1, GETDATE())
)
SELECT 
    COALESCE(c.EmployeeID, o.EmployeeID) AS EmployeeID,
    c.Position AS CurrentPosition,
    o.Position AS OldPosition,
    c.Salary AS CurrentSalary,
    o.Salary AS OldSalary,
    CASE 
        WHEN c.EmployeeID IS NULL THEN 'Уволен'
        WHEN o.EmployeeID IS NULL THEN 'Нанят'
        WHEN c.Position <> o.Position THEN 'Повышение/понижение'
        WHEN c.Salary <> o.Salary THEN 'Изменение зарплаты'
        ELSE 'Без изменений'
    END AS ChangeType
FROM CurrentData c
FULL OUTER JOIN OldData o ON c.EmployeeID = o.EmployeeID
WHERE c.EmployeeID IS NULL 
   OR o.EmployeeID IS NULL
   OR c.Position <> o.Position
   OR c.Salary <> o.Salary;
```

#### **3.3. Управление данными в темпоральных таблицах**

```sql
-- 1. Вставка новых данных (как в обычную таблицу)
INSERT INTO dbo.Employees (EmployeeID, LastName, Position, Salary)
VALUES (1001, 'Иванов', 'Разработчик', 150000);

-- 2. Обновление - старая версия перемещается в историю
UPDATE dbo.Employees
SET Salary = 160000, Position = 'Старший разработчик'
WHERE EmployeeID = 1001;
-- В истории появляется запись с Salary=150000, Position='Разработчик'

-- 3. Удаление - строка перемещается в историю
DELETE FROM dbo.Employees
WHERE EmployeeID = 1001;
-- В истории: SysEndTime = время удаления

-- 4. Восстановление данных из истории
-- Вариант 1: Восстановление удаленной строки
INSERT INTO dbo.Employees (EmployeeID, LastName, Position, Salary)
SELECT EmployeeID, LastName, Position, Salary
FROM dbo.Employees
FOR SYSTEM_TIME AS OF '2024-01-01'
WHERE EmployeeID = 1001;

-- Вариант 2: Откат ошибочного обновления
UPDATE e
SET e.Salary = h.Salary,
    e.Position = h.Position
FROM dbo.Employees e
JOIN dbo.Employees FOR SYSTEM_TIME AS OF '2024-01-01' h 
    ON e.EmployeeID = h.EmployeeID
WHERE e.EmployeeID = 1001;

-- 5. Очистка старых данных из истории
-- Сначала отключаем системное контролирование версий
ALTER TABLE dbo.Employees
SET (SYSTEM_VERSIONING = OFF);

-- Удаляем старые записи из таблицы истории
DELETE FROM dbo.Employees_History
WHERE SysEndTime < DATEADD(YEAR, -2, GETDATE());

-- Включаем обратно
ALTER TABLE dbo.Employees
SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.Employees_History));
```

#### **3.4. Управление таблицей истории**

```sql
-- 1. Создание индексов для оптимизации запросов
CREATE INDEX IX_EmployeesHistory_EmployeeID 
ON dbo.Employees_History (EmployeeID, SysStartTime, SysEndTime);

CREATE INDEX IX_EmployeesHistory_Period 
ON dbo.Employees_History (SysStartTime, SysEndTime)
INCLUDE (EmployeeID, LastName);

-- 2. Сжатие таблицы истории
ALTER INDEX ALL ON dbo.Employees_History REORGANIZE 
WITH (COMPRESS_ALL_ROW_GROUPS = ON);

-- 3. Разделение (партиционирование) таблицы истории
-- По годам для быстрой очистки старых данных
CREATE PARTITION FUNCTION pf_EmployeeHistoryYears (DATETIME2)
AS RANGE RIGHT FOR VALUES (
    '2020-01-01', '2021-01-01', '2022-01-01',
    '2023-01-01', '2024-01-01', '2025-01-01'
);

CREATE PARTITION SCHEME ps_EmployeeHistoryYears
AS PARTITION pf_EmployeeHistoryYears
ALL TO ([PRIMARY]);

-- Пересоздание таблицы истории с партиционированием
-- (требуется временное отключение SYSTEM_VERSIONING)
```

---

### **Часть 4. Практические сценарии использования**

#### **4.1. Сценарий 1: Аудит изменений данных**

```sql
-- Автоматический аудит без триггеров
CREATE TABLE dbo.ProductPrices
(
    ProductID INT NOT NULL PRIMARY KEY,
    ProductName NVARCHAR(100) NOT NULL,
    Price DECIMAL(10,2) NOT NULL,
    UpdatedBy NVARCHAR(128) NOT NULL DEFAULT SYSTEM_USER,
    
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START NOT NULL,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END NOT NULL,
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime)
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductPrices_History));

-- Отчет по изменениям цен за период
SELECT 
    ProductID,
    ProductName,
    Price,
    UpdatedBy,
    SysStartTime AS ChangeTime,
    LAG(Price) OVER (PARTITION BY ProductID ORDER BY SysStartTime) AS PreviousPrice,
    CASE 
        WHEN LAG(Price) OVER (PARTITION BY ProductID ORDER BY SysStartTime) IS NULL 
            THEN 'Новая цена'
        WHEN Price > LAG(Price) OVER (PARTITION BY ProductID ORDER BY SysStartTime) 
            THEN 'Повышение'
        ELSE 'Понижение'
    END AS ChangeType
FROM dbo.ProductPrices
FOR SYSTEM_TIME 
    FROM '2024-01-01' TO '2024-12-31'
ORDER BY ProductID, SysStartTime;
```

#### **4.2. Сценарий 2: Юридическое соответствие (GDPR, SOX)**

```sql
-- Хранение истории изменений для соответствия регуляторным требованиям
CREATE TABLE dbo.CustomerConsents
(
    ConsentID UNIQUEIDENTIFIER DEFAULT NEWID() PRIMARY KEY,
    CustomerID INT NOT NULL,
    ConsentType NVARCHAR(50) NOT NULL,
    ConsentGiven BIT NOT NULL,
    GivenDate DATETIME NOT NULL,
    ExpiryDate DATETIME NULL,
    
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START NOT NULL,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END NOT NULL,
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime)
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.CustomerConsents_History));

-- Доказательство согласия на конкретную дату
SELECT *
FROM dbo.CustomerConsents
FOR SYSTEM_TIME AS OF '2024-03-15 14:30:00'
WHERE CustomerID = 12345
    AND ConsentType = 'MarketingEmails'
    AND ConsentGiven = 1;
```

#### **4.3. Сценарий 3: Анализ трендов и KPI**

```sql
-- Анализ изменения структуры отделов
WITH DepartmentSnapshots AS (
    SELECT 
        EmployeeID,
        DepartmentID,
        SysStartTime AS SnapshotDate,
        LEAD(SysStartTime) OVER (
            PARTITION BY EmployeeID 
            ORDER BY SysStartTime
        ) AS NextSnapshotDate
    FROM dbo.Employees
    FOR SYSTEM_TIME ALL
)
SELECT 
    DATEFROMPARTS(YEAR(s.SnapshotDate), MONTH(s.SnapshotDate), 1) AS Month,
    d.DepartmentName,
    COUNT(DISTINCT s.EmployeeID) AS EmployeeCount
FROM DepartmentSnapshots s
JOIN dbo.Departments d ON s.DepartmentID = d.DepartmentID
WHERE s.NextSnapshotDate IS NULL 
   OR s.NextSnapshotDate >= DATEADD(MONTH, 1, s.SnapshotDate)
GROUP BY 
    DATEFROMPARTS(YEAR(s.SnapshotDate), MONTH(s.SnapshotDate), 1),
    d.DepartmentName
ORDER BY Month, DepartmentName;
```

#### **4.4. Сценарий 4: Откат ошибочных операций**

```sql
-- Восстановление состояния после ошибочного массового обновления
BEGIN TRANSACTION;

-- 1. Запоминаем время до ошибки
DECLARE @BeforeErrorTime DATETIME2 = SYSUTCDATETIME();

-- 2. Ошибочное обновление (например, всем повысили зарплату в 10 раз)
UPDATE dbo.Employees
SET Salary = Salary * 10; -- ОШИБКА!

-- 3. Откат к состоянию до ошибки
MERGE dbo.Employees AS target
USING (
    SELECT * 
    FROM dbo.Employees 
    FOR SYSTEM_TIME AS OF @BeforeErrorTime
) AS source ON target.EmployeeID = source.EmployeeID
WHEN MATCHED THEN
    UPDATE SET 
        target.Salary = source.Salary,
        target.Position = source.Position,
        target.DepartmentID = source.DepartmentID;

COMMIT TRANSACTION;
```

---

### **Часть 5. Производительность и оптимизация**

#### **5.1. Производительность темпоральных таблиц**

**Преимущества по сравнению с ручным аудитом:**
- **Автоматическое управление** - не нужны триггеры
- **Оптимизированные запросы** - специальный синтаксис FOR SYSTEM_TIME
- **Минимальное влияние** на производительность DML-операций
- **Стандартизированный доступ** к историческим данным

**Рекомендации по производительности:**
```sql
-- 1. Индексы на таблице истории
-- Обязательно: (SysStartTime, SysEndTime) для временных запросов
-- Рекомендуется: (BusinessKey, SysStartTime, SysEndTime) для запросов по объекту

-- 2. Партиционирование истории по времени
-- Для быстрой очистки старых данных
-- Для параллельного выполнения запросов

-- 3. Сжатие данных
-- История обычно хорошо сжимается
ALTER TABLE dbo.Employees_History REBUILD PARTITION = ALL
WITH (DATA_COMPRESSION = PAGE);

-- 4. Отдельный файлгрупп для истории
-- Размещение на более медленных/дешевых дисках
ALTER DATABASE MyDB ADD FILEGROUP HistoryFG;
ALTER DATABASE MyDB ADD FILE (
    NAME = HistoryData,
    FILENAME = 'E:\Data\HistoryData.ndf',
    SIZE = 10GB
) TO FILEGROUP HistoryFG;

ALTER TABLE dbo.Employees_History
SET (SYSTEM_VERSIONING = OFF);

ALTER TABLE dbo.Employees_History
DROP CONSTRAINT PK_Employees_History
WITH (MOVE TO HistoryFG);

ALTER TABLE dbo.Employees
SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.Employees_History));
```

#### **5.2. Мониторинг использования**

```sql
-- Размер таблицы истории
SELECT 
    OBJECT_NAME(object_id) AS TableName,
    SUM(row_count) AS TotalRows,
    (SUM(used_page_count) * 8) / 1024.0 AS SizeMB
FROM sys.dm_db_partition_stats
WHERE object_id IN (
    OBJECT_ID('dbo.Employees'),
    OBJECT_ID('dbo.Employees_History')
)
GROUP BY object_id;

-- Активность изменений
SELECT 
    COUNT(*) AS ChangeCount,
    DATEPART(HOUR, SysStartTime) AS HourOfDay,
    CASE 
        WHEN SysEndTime = '9999-12-31 23:59:59.9999999' 
        THEN 'Current' 
        ELSE 'History' 
    END AS RowType
FROM dbo.Employees
FOR SYSTEM_TIME ALL
WHERE SysStartTime >= DATEADD(DAY, -1, GETDATE())
GROUP BY 
    DATEPART(HOUR, SysStartTime),
    CASE 
        WHEN SysEndTime = '9999-12-31 23:59:59.9999999' 
        THEN 'Current' 
        ELSE 'History' 
    END
ORDER BY HourOfDay, RowType;

-- Поиск часто изменяемых строк
SELECT 
    EmployeeID,
    COUNT(*) AS ChangeCount,
    MIN(SysStartTime) AS FirstChange,
    MAX(SysStartTime) AS LastChange
FROM dbo.Employees
FOR SYSTEM_TIME ALL
GROUP BY EmployeeID
HAVING COUNT(*) > 10
ORDER BY ChangeCount DESC;
```

---

### **Часть 6. Альтернативные подходы**

#### **6.1. Ручное управление историей (до темпоральных таблиц)**

```sql
-- Старый подход с триггерами
CREATE TABLE dbo.Employees_Audit (
    AuditID INT IDENTITY PRIMARY KEY,
    EmployeeID INT NOT NULL,
    ChangeType CHAR(1) NOT NULL, -- 'I', 'U', 'D'
    OldData XML NULL,
    NewData XML NULL,
    ChangedBy NVARCHAR(128) NOT NULL,
    ChangedDate DATETIME NOT NULL DEFAULT GETDATE()
);

CREATE TRIGGER trg_Employees_Audit
ON dbo.Employees
AFTER INSERT, UPDATE, DELETE
AS
BEGIN
    INSERT INTO dbo.Employees_Audit (EmployeeID, ChangeType, OldData, NewData, ChangedBy)
    SELECT 
        COALESCE(i.EmployeeID, d.EmployeeID),
        CASE 
            WHEN i.EmployeeID IS NOT NULL AND d.EmployeeID IS NOT NULL THEN 'U'
            WHEN i.EmployeeID IS NOT NULL THEN 'I'
            ELSE 'D'
        END,
        (SELECT d.* FOR XML PATH(''), TYPE),
        (SELECT i.* FOR XML PATH(''), TYPE),
        SYSTEM_USER
    FROM inserted i
    FULL OUTER JOIN deleted d ON i.EmployeeID = d.EmployeeID;
END;
```

#### **6.2. Change Data Capture (CDC)**

```sql
-- Включение CDC на уровне базы данных
EXEC sys.sp_cdc_enable_db;

-- Включение CDC для таблицы
EXEC sys.sp_cdc_enable_table
    @source_schema = N'dbo',
    @source_name = N'Employees',
    @role_name = N'cdc_admin',
    @capture_instance = N'dbo_Employees';

-- Получение изменений
SELECT * FROM cdc.dbo_Employees_CT
WHERE __$operation IN (1, 2, 4)  -- 1=delete, 2=insert, 4=update
ORDER BY __$start_lsn;
```

---

### **3. Заключение**

**Ключевые выводы:**

1.  **Временные таблицы** (`#temp`) идеальны для промежуточных вычислений в сессии.
2.  **Темпоральные таблицы** революционизировали управление историей данных.
3.  **Автоматическое ведение истории** устраняет сложность триггеров и ручного аудита.
4.  **Стандартизированные запросы** к истории (`FOR SYSTEM_TIME`) упрощают анализ.

**Рекомендации по использованию:**

1.  **Используйте темпоральные таблицы** для:
    - Аудита изменений
    - Соответствия регуляторным требованиям
    - Анализа исторических трендов
    - Восстановления после ошибок

2.  **Оптимизируйте производительность:**
    - Индексы на таблице истории
    - Партиционирование по времени
    - Отдельные файлгруппы для истории
    - Регулярное обслуживание

3.  **Управляйте ростом истории:**
    - Политики очистки старых данных
    - Мониторинг размера истории
    - Архивация очень старых данных

4.  **Тестируйте запросы к истории:** 
    - Производительность запросов `FOR SYSTEM_TIME`
    - Влияние на операции DML

**Современные тенденции:**
- **Встроенная темпоральность** в новых версиях СУБД
- **Интеграция с BI-инструментами** для анализа истории
- **Автоматическое сжатие** исторических данных
- **Облачные реализации** с автоматическим масштабированием

**Итог:** Темпоральные таблицы представляют собой **квантовый скачок** в управлении историей данных. Они превращают сложную, подверженную ошибкам задачу ручного аудита в простую, встроенную функцию СУБД. Для новых проектов темпоральные таблицы должны быть **стандартным выбором** для любого сценария, требующего отслеживания истории изменений.