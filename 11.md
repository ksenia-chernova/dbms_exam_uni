### Понятие хранимой процедуры. Создание процедуры средствами Transact-SQL

### **Часть 1. Понятие хранимой процедуры**

**Хранимая процедура (Stored Procedure)** — это именованный программный модуль (набор предварительно компилированных инструкций SQL и процедурных расширений), который сохраняется на сервере базы данных и может быть многократно вызван клиентскими приложениями или другими процедурами.

**Назначение:** Инкапсуляция сложной бизнес-логики, операций с данными и административных задач непосредственно на стороне сервера БД.

#### **Ключевые преимущества хранимых процедур:**

| Преимущество | Описание |
| :--- | :--- |
| **Производительность** | • **Предварительная компиляция:** План выполнения кэшируется после первого запуска, последующие вызовы быстрее.<br>• **Снижение сетевого трафика:** Вместо десятков запросов по сети отправляется один вызов процедуры. |
| **Безопасность** | • **Контроль доступа:** Права можно выдать на выполнение процедуры, не давая прямого доступа к таблицам (принцип наименьших привилегий).<br>• **Защита от SQL-инъекций:** Параметры передаются безопасно, не интерпретируются как часть кода SQL. |
| **Централизация логики и сопровождение** | • **Единая точка изменения:** Логика меняется в одном месте (на сервере), а не во всех клиентских приложениях.<br>• **Сокрытие сложности:** Процедура предоставляет простой интерфейс для сложных операций с данными. |
| **Целостность транзакций** | Позволяют объединять несколько операций в одну атомарную транзакцию с обработкой ошибок. |
| **Модульность и повторное использование** | Код пишется один раз и используется многократно разными приложениями. |

#### **Недостатки и критика:**

1.  **Сложность отладки и тестирования:** Требуют специализированных инструментов (SQL Server Management Studio — SSMS, Visual Studio).
2.  **Привязка к вендору (Vendor Lock-in):** Процедуры на T-SQL не переносятся на другие СУБД (Oracle PL/SQL, PostgreSQL PL/pgSQL).
3.  **Потенциальное размывание архитектуры:** Чрезмерное размещение бизнес-логики в БД может усложнить развертывание и нарушить принципы многоуровневой архитектуры.
4.  **Сложность контроля версий:** Интеграция с системами контроля версий (Git) требует дополнительных усилий.

---

### **Часть 2. Создание процедуры средствами Transact-SQL: Синтаксис и компоненты**

Базовый синтаксис команды `CREATE PROCEDURE`:

```sql
CREATE { PROC | PROCEDURE } [schema_name.]procedure_name
    [ { @parameter [ type_schema_name. ] data_type }
        [ = default ] [ OUT | OUTPUT ] [ READONLY ]
    ] [ ,...n ]
[ WITH 
    [ ENCRYPTION ] -- Шифрование текста процедуры
    [ , RECOMPILE ] -- Принудительная перекомпиляция при каждом запуске
    [ , EXECUTE AS { CALLER | SELF | OWNER | 'user_name' } ] -- Контекст безопасности
]
AS
    { [ BEGIN ] sql_statement [;] [ ...n ] [ END ] }
[;]
```

#### **Ключевые компоненты создания:**

**1. Имя и схема:**
*   `[schema_name.]procedure_name` — имя процедуры, желательно в схеме (например, `dbo.usp_GetEmployeeOrders`). Префикс `usp_` (user stored procedure) — распространенное соглашение.

**2. Параметры:**
*   `@parameter` — имя параметра, всегда начинается с `@`.
*   `data_type` — тип данных параметра.
*   `= default` — значение параметра по умолчанию.
*   `OUTPUT` (или `OUT`) — указывает, что параметр является выходным (возвращается вызывающему коду).
*   `READONLY` — для табличных параметров, запрещает изменение внутри процедуры.

**3. Опции создания (`WITH`):**
*   `ENCRYPTION` — шифрует текст процедуры в системных таблицах (защита от просмотра, но усложняет сопровождение).
*   `RECOMPILE` — указывает, что план выполнения не должен кэшироваться. Полезно для процедур с непредсказуемыми параметрами.
*   `EXECUTE AS` — задает контекст безопасности, под которым будет выполняться процедура.

**4. Тело процедуры (`AS ... BEGIN ... END`):**
*   Содержит исполняемый код: операторы T-SQL, управляющие конструкции, вызовы других процедур.
*   **Обязательно использовать `BEGIN...END` для многооператорных процедур.**

---

### **Часть 3. Практический пример: Создание и использование процедуры**

**Задача:** Создать процедуру для добавления нового заказа в систему с проверкой наличия товара на складе и обновлением его остатков. В случае ошибки — откат всей операции.

```sql
-- 1. Создание процедуры
CREATE PROCEDURE dbo.usp_AddNewOrder
    -- Входные параметры
    @CustomerID INT,
    @ProductID INT,
    @OrderQuantity INT,
    -- Выходной параметр для статуса/ID заказа
    @NewOrderID INT OUTPUT,
    @StatusMessage NVARCHAR(100) OUTPUT
AS
BEGIN
    -- Установка начальных значений выходных параметров
    SET @NewOrderID = -1;
    SET @StatusMessage = N'Начало обработки';

    -- Объявление локальной переменной для контроля транзакции
    DECLARE @TransactionCount INT = @@TRANCOUNT;
    
    BEGIN TRY
        -- Начало явной транзакции (если не было начато извне)
        IF @TransactionCount = 0
            BEGIN TRANSACTION;

        -- 1. Проверка наличия товара на складе
        DECLARE @StockQuantity INT;
        SELECT @StockQuantity = QuantityInStock 
        FROM dbo.Products WITH (UPDLOCK) -- Блокировка для обновления
        WHERE ProductID = @ProductID;

        IF @StockQuantity IS NULL
        BEGIN
            SET @StatusMessage = N'Товар с ID=' + CAST(@ProductID AS NVARCHAR) + N' не найден';
            THROW 51000, @StatusMessage, 1; -- Генерация пользовательской ошибки
        END

        IF @StockQuantity < @OrderQuantity
        BEGIN
            SET @StatusMessage = N'Недостаточно товара на складе. Доступно: ' + CAST(@StockQuantity AS NVARCHAR);
            THROW 51001, @StatusMessage, 1;
        END

        -- 2. Вставка записи в таблицу заказов
        INSERT INTO dbo.Orders (CustomerID, OrderDate, Status)
        VALUES (@CustomerID, GETDATE(), N'Новый');
        
        -- Получение ID созданного заказа (SCOPE_IDENTITY безопаснее @@IDENTITY)
        SET @NewOrderID = SCOPE_IDENTITY();

        -- 3. Добавление позиции в заказ
        INSERT INTO dbo.OrderDetails (OrderID, ProductID, Quantity, UnitPrice)
        SELECT 
            @NewOrderID, 
            @ProductID, 
            @OrderQuantity,
            Price
        FROM dbo.Products 
        WHERE ProductID = @ProductID;

        -- 4. Обновление остатков товара на складе
        UPDATE dbo.Products
        SET QuantityInStock = QuantityInStock - @OrderQuantity,
            LastStockUpdate = GETDATE()
        WHERE ProductID = @ProductID;

        -- 5. Фиксация транзакции, если мы ее начали
        IF @TransactionCount = 0
            COMMIT TRANSACTION;

        SET @StatusMessage = N'Заказ успешно создан. ID заказа: ' + CAST(@NewOrderID AS NVARCHAR);
        
    END TRY
    BEGIN CATCH
        -- Откат транзакции, если мы ее начали
        IF @TransactionCount = 0 AND @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;

        -- Формирование сообщения об ошибке
        SET @StatusMessage = N'Ошибка: ' + ERROR_MESSAGE() 
                           + N'. Код: ' + CAST(ERROR_NUMBER() AS NVARCHAR)
                           + N'. Процедура: ' + ERROR_PROCEDURE();

        -- Можно логировать ошибку в отдельную таблицу
        INSERT INTO dbo.ErrorLog (ErrorMessage, ErrorNumber, ProcedureName, CreatedAt)
        VALUES (ERROR_MESSAGE(), ERROR_NUMBER(), ERROR_PROCEDURE(), GETDATE());
        
        -- Проброс ошибки наверх (клиенту)
        THROW;
    END CATCH
END;
GO
```

**Вызов процедуры и работа с выходными параметрами:**

```sql
-- 2. Объявление переменных для приема выходных параметров
DECLARE @ResultOrderID INT;
DECLARE @ResultMessage NVARCHAR(100);

-- 3. Вызов процедуры с передачей параметров
EXEC dbo.usp_AddNewOrder 
    @CustomerID = 123,
    @ProductID = 456,
    @OrderQuantity = 5,
    @NewOrderID = @ResultOrderID OUTPUT, -- Указываем, что параметр выходной
    @StatusMessage = @ResultMessage OUTPUT;

-- 4. Использование результатов
PRINT @ResultMessage;
PRINT 'Создан заказ с ID: ' + CAST(@ResultOrderID AS NVARCHAR(10));

-- Или выборка для клиентского приложения
SELECT 
    OrderID = @ResultOrderID,
    StatusMessage = @ResultMessage;
```

**Дополнительные операции с процедурами:**
```sql
-- Изменение процедуры (ALTER вместо DROP/CREATE, сохраняются права)
ALTER PROCEDURE dbo.usp_AddNewOrder ...

-- Удаление процедуры
DROP PROCEDURE dbo.usp_AddNewOrder;

-- Просмотр текста процедуры (если не зашифрована)
sp_helptext 'dbo.usp_AddNewOrder';

-- Просмотр информации о параметрах
sp_help 'dbo.usp_AddNewOrder';
```

---

### **3. Заключение**

**Хранимая процедура в T-SQL** — это мощный инструмент для:
1.  **Инкапсуляции** сложной многошаговой логики работы с данными.
2.  **Гарантии** атомарности и целостности через управление транзакциями.
3.  **Повышения** производительности и безопасности приложения.
4.  **Стандартизации** способов доступа к данным для различных клиентов.

**Критерии хорошей хранимой процедуры:**
*   Четкое, осмысленное имя (желательно с префиксом, указывающим назначение).
*   Полноценная обработка ошибок через `TRY...CATCH`.
*   Корректное управление транзакциями (учет вложенности).
*   Использование параметризованных запросов.
*   Комментарии для сложных участков кода.
*   Возврат информативных сообщений о статусе выполнения (через выходные параметры или `RAISERROR`/`THROW`).

**Важно помнить:** Современная архитектура часто рекомендует выносить сложную бизнес-логику в слой приложения (Backend), оставляя в хранимых процедурах только **логику, тесно связанную с данными** (сложные выборки, массовые обновления, целостные транзакции).