### Понятие индекса, основные виды индексов и особенности их использования

### **Часть 1. Понятие и назначение индексов**

**Индекс** — это вспомогательная структура данных, которая **ускоряет операции поиска и сортировки** в таблице за счет дополнительных расходов на хранение и поддержку.

**Аналогия с книгой:** Если таблица — это книга, то сканирование всей таблицы (Table Scan) — это чтение книги от корки до корки. Индекс — это алфавитный указатель в конце книги, который позволяет быстро найти нужную информацию.

#### **Основные цели индексов:**
1.  **Ускорение поиска** (`WHERE`, `JOIN`)
2.  **Ускорение сортировки** (`ORDER BY`, `GROUP BY`)
3.  **Обеспечение уникальности** (`UNIQUE CONSTRAINT`)
4.  **Ускорение агрегации**

#### **Внутренняя структура индекса (B-дерево):**

Большинство индексов в SQL Server основаны на **B-дереве (B+ tree)** — сбалансированном дереве поиска.

```
Уровень 0 (Корень / Root)
       [25|50|75]  ← Указатели на страницы следующего уровня
         /   |   \
        /    |    \
Уровень 1 (Промежуточный / Intermediate)
 [10|20] [30|40] [60|70] [80|90]
   / \     / \     / \     / \
Уровень 2 (Листовой / Leaf)
[Данные или указатели на данные]
```

**Свойства B-дерева:**
- **Сбалансированность:** Все листья находятся на одном уровне
- **Многоуровневость:** O(log n) сложность поиска
- **Страничная организация:** Данные хранятся в страницах по 8 КБ

#### **Компоненты затрат на индекс:**
1.  **Пространство:** Дополнительное место на диске (20-30% от размера таблицы)
2.  **Время на поддержку:** Замедление `INSERT`, `UPDATE`, `DELETE`
3.  **Время на планирование:** Оптимизатор тратит время на выбор индекса

**Золотое правило:** Индекс должен **ускорять чтение больше, чем замедлять запись**.

---

### **Часть 2. Классификация индексов**

#### **2.1. По структуре хранения данных**

| Тип | Основная идея | Структура | Особенности |
| :--- | :--- | :--- | :--- |
| **Кластеризованный (Clustered)** | **Данные отсортированы физически** на диске в порядке индекса. Сам индекс — это таблица. | B-дерево, где листья — сами строки данных | 1 на таблицу, быстрый диапазонный поиск, замедляет вставку |
| **Некластеризованный (Non-Clustered)** | **Отдельная структура**, содержащая ключ + указатель на строку. | B-дерево, где листья — либо RID (для кучи), либо ключ кластеризованного индекса | До 999 на таблицу, требует дополнительного чтения |

#### **2.2. По типу данных и назначению**

| Тип | Назначение | Структура | Использование |
| :--- | :--- | :--- | :--- |
| **Columnstore** | Для аналитики (OLAP), агрегаций | Данные хранятся по столбцам, а не строкам | Data Warehousing, тяжелая аналитика |
| **Полнотекстовый (Full-Text)** | Поиск по тексту (слова, фразы) | Инвертированный индекс слов + позиции | Поиск в документах, статьях |
| **Пространственный (Spatial)** | Географические/геометрические данные | R-дерево, сеточная иерархия | GIS-системы, карты |
| **XML** | Индексация XML-документов | B-дерево по путям и значениям | Работа с XML-данными |
| **Хэш-индекс (In-Memory OLTP)** | Точечный поиск в памяти | Хэш-таблица | Высокоскоростные OLTP в памяти |

---

### **Часть 3. Особенности использования различных индексов**

#### **3.1. Кластеризованный индекс (Clustered Index)**

**Когда создавать:**
- Таблица имеет естественный ключ, по которому часто выполняется сортировка
- Частые запросы по диапазону значений
- Нужен физический порядок данных для секционирования

**Синтаксис:**
```sql
-- При создании таблицы
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY CLUSTERED,  -- Автоматически кластеризованный
    LastName NVARCHAR(50),
    FirstName NVARCHAR(50)
);

-- Для существующей таблицы
CREATE CLUSTERED INDEX IX_Employees_EmployeeID 
ON Employees(EmployeeID);

-- Составной кластеризованный индекс
CREATE CLUSTERED INDEX IX_Orders_DateCustomer 
ON Orders(OrderDate DESC, CustomerID);
```

**Особенности:**
- Определяет **физический порядок** данных на диске
- **Листовой уровень** — сами данные таблицы
- **Только один** на таблицу
- **Размер ключа должен быть небольшим** (влияет на все некластеризованные индексы)

#### **3.2. Некластеризованный индекс (Non-Clustered Index)**

**Когда создавать:**
- Частые поиски по неключевым столбцам
- Нужно покрыть запрос (covering index)
- Ограничения уникальности

**Синтаксис:**
```sql
-- Простой некластеризованный индекс
CREATE NONCLUSTERED INDEX IX_Employees_LastName
ON Employees(LastName);

-- Составной индекс
CREATE NONCLUSTERED INDEX IX_Employees_NameDept
ON Employees(LastName, FirstName, DepartmentID);

-- Уникальный индекс
CREATE UNIQUE NONCLUSTERED INDEX UQ_Employees_Email
ON Employees(Email);

-- Индекс с включенными столбцами (Covering Index)
CREATE NONCLUSTERED INDEX IX_Orders_Covering
ON Orders(CustomerID, OrderDate)
INCLUDE (TotalAmount, Status);  -- Данные хранятся в листьях
```

**Проблема Key Lookup (Bookmark Lookup):**
```sql
-- Запрос вызывает Key Lookup
SELECT EmployeeID, LastName, Salary 
FROM Employees 
WHERE LastName = 'Smith';
-- Индекс IX_Employees_LastName содержит только LastName + указатель
-- Нужно дополнительное чтение для получения Salary

-- Решение: покрывающий индекс
CREATE INDEX IX_Employees_LastName_Covering
ON Employees(LastName)
INCLUDE (Salary);
```

#### **3.3. Индексы Columnstore**

**Назначение:** Для **аналитических запросов** с агрегацией больших объемов данных.

**Преимущества:**
- Сжатие данных до **10x**
- Векторизованное выполнение (batch mode)
- Эффективная агрегация

**Синтаксис:**
```sql
-- Кластеризованный columnstore индекс (вся таблица)
CREATE CLUSTERED COLUMNSTORE INDEX CCI_Sales 
ON Sales;

-- Некластеризованный columnstore индекс (часть данных)
CREATE NONCLUSTERED COLUMNSTORE INDEX NCCI_Orders
ON Orders(OrderDate, CustomerID, TotalAmount)
WHERE OrderDate >= '2020-01-01';
```

**Когда использовать:**
- Data warehouse, аналитические отчеты
- Запросы с `SUM()`, `AVG()`, `GROUP BY`
- Таблицы от **1 млн строк**

#### **3.4. Фильтрованные индексы (Filtered)**

**Назначение:** Индекс для подмножества строк.

**Преимущества:**
- Меньший размер
- Быстрее обслуживание
- Лучшая статистика

**Пример:**
```sql
-- Индекс только для активных заказов
CREATE NONCLUSTERED INDEX IX_Orders_Active
ON Orders(CustomerID, OrderDate)
WHERE Status = 'Active';  -- Только 10% строк

-- Индекс для не-NULL значений
CREATE INDEX IX_Employees_Phone
ON Employees(PhoneNumber)
WHERE PhoneNumber IS NOT NULL;
```

---

### **Часть 4. Стратегии создания и обслуживания индексов**

#### **4.1. Как выбирать столбцы для индекса?**

**Высокая селективность (кардинальность):**
```sql
-- ХОРОШО: Высокая селективность (много уникальных значений)
CREATE INDEX IX_Employees_SSN ON Employees(SSN);

-- ПЛОХО: Низкая селективность (мало уникальных значений)
CREATE INDEX IX_Employees_Gender ON Employees(Gender); -- 'M', 'F'

-- ХОРОШО: Составной индекс на несколько столбцов
CREATE INDEX IX_Orders_DateCustomer ON Orders(OrderDate, CustomerID);
```

**Правило "левый префикс" (Leftmost Prefix):**
```sql
CREATE INDEX IX_Employees_NameDept ON Employees(LastName, FirstName, DepartmentID);

-- БУДЕТ использоваться индекс:
SELECT * FROM Employees WHERE LastName = 'Smith';
SELECT * FROM Employees WHERE LastName = 'Smith' AND FirstName = 'John';
SELECT * FROM Employees WHERE LastName = 'Smith' AND FirstName = 'John' AND DepartmentID = 5;

-- НЕ БУДЕТ использоваться (или будет частично):
SELECT * FROM Employees WHERE FirstName = 'John';  -- Пропущен LastName
SELECT * FROM Employees WHERE DepartmentID = 5;    -- Пропущены оба предыдущих
```

#### **4.2. Покрывающие индексы (Covering Indexes)**

**Идея:** Индекс содержит **все столбцы**, необходимые для запроса.
```sql
-- Запрос
SELECT OrderID, CustomerID, OrderDate, TotalAmount
FROM Orders
WHERE CustomerID = 123 AND OrderDate BETWEEN '2024-01-01' AND '2024-12-31';

-- Оптимальный покрывающий индекс
CREATE INDEX IX_Orders_Covering
ON Orders(CustomerID, OrderDate)
INCLUDE (TotalAmount, Status);
-- OrderID уже в ключе кластеризованного индекса
```

#### **4.3. Обслуживание индексов**

**Проблемы:**
1.  **Фрагментация:** Страницы индекса становятся неупорядоченными
2.  **Устаревшая статистика:** Оптимизатор выбирает плохие планы

**Мониторинг:**
```sql
-- Фрагментация индексов
SELECT 
    object_name(ips.object_id) AS TableName,
    si.name AS IndexName,
    ips.avg_fragmentation_in_percent,
    ips.page_count
FROM sys.dm_db_index_physical_stats(
    DB_ID(), NULL, NULL, NULL, 'LIMITED') ips
JOIN sys.indexes si ON ips.object_id = si.object_id 
    AND ips.index_id = si.index_id
WHERE ips.avg_fragmentation_in_percent > 30
ORDER BY ips.avg_fragmentation_in_percent DESC;

-- Неиспользуемые индексы
SELECT 
    object_name(i.object_id) AS TableName,
    i.name AS IndexName,
    ius.user_seeks,
    ius.user_scans,
    ius.user_lookups,
    ius.user_updates
FROM sys.indexes i
LEFT JOIN sys.dm_db_index_usage_stats ius 
    ON i.object_id = ius.object_id AND i.index_id = ius.index_id
WHERE ius.database_id = DB_ID()
ORDER BY (ius.user_seeks + ius.user_scans + ius.user_lookups) ASC;
```

**Обслуживание:**
```sql
-- Перестроение индекса (полное, требует больше ресурсов)
ALTER INDEX IX_Employees_LastName ON Employees REBUILD;

-- Реорганизация индекса (дефрагментация, онлайн)
ALTER INDEX ALL ON Employees REORGANIZE;

-- Обновление статистики
UPDATE STATISTICS Employees WITH FULLSCAN;

-- Автоматическое обслуживание (рекомендуется)
-- Использовать Maintenance Plans или Ola Hallengren scripts
```

#### **4.4. Рекомендации по проектированию индексов**

1.  **Начинайте с кластеризованного индекса:**
    - Лучше на монотонно возрастающем ключе (IDENTITY)
    - Узкий (мало столбцов, небольшие типы данных)

2.  **Создавайте индексы на основе запросов:**
    - Анализируйте планы выполнения
    - Используйте Database Engine Tuning Advisor

3.  **Избегайте избыточных индексов:**
    ```sql
    -- ИЗБЫТОЧНО:
    CREATE INDEX IX1 ON T(A, B, C);
    CREATE INDEX IX2 ON T(A, B);  -- Уже покрывается IX1
    
    -- ДОСТАТОЧНО:
    CREATE INDEX IX ON T(A, B, C);
    ```

4.  **Учитывайте операторы в WHERE:**
    ```sql
    -- SARGable (может использовать индекс)
    WHERE DateColumn >= '2024-01-01'
    WHERE Name LIKE 'Smith%'  -- Префиксный поиск
    
    -- Non-SARGable (НЕ использует индекс)
    WHERE YEAR(DateColumn) = 2024  -- Функция над столбцом
    WHERE Name LIKE '%Smith'       -- Суффиксный поиск
    WHERE Amount * 1.1 > 100       -- Вычисление
    ```

5.  **Индексы для JOIN:**
    - Индексируйте столбцы внешних ключей
    - Рассмотрите покрывающие индексы для часто используемых JOIN

6.  **Индексы для сортировки:**
    ```sql
    -- Запрос
    SELECT * FROM Orders 
    WHERE CustomerID = 123 
    ORDER BY OrderDate DESC;
    
    -- Оптимальный индекс
    CREATE INDEX IX_Orders_CustomerDate 
    ON Orders(CustomerID, OrderDate DESC);
    ```

---

### **5. Практические антипаттерны**

| **Антипаттерн** | **Проблема** | **Решение** |
| :--- | :--- | :--- |
| **Индексы на все столбцы** | Замедление DML, большой размер | Создавать только нужные индексы |
| **Широкие составные индексы** | Большой размер, медленное обслуживание | Использовать `INCLUDE` для непоисковых столбцов |
| **Дублирующие индексы** | Лишнее потребление ресурсов | Удалять дубликаты |
| **Отсутствие обслуживания** | Фрагментация, плохая производительность | Регулярное перестроение/реорганизация |
| **Индексы на BIT столбцы** | Низкая селективность | Фильтрованные индексы или избегать |

---

### **3. Заключение**

**Индексы — это баланс между чтением и записью.** Правильная индексация может ускорить запросы в **сотни раз**, неправильная — полностью парализовать систему.

**Ключевые принципы:**
1.  **Измеряйте, не предполагайте:** Анализируйте фактические запросы и планы выполнения.
2.  **Индекс — не волшебная таблетка:** Он помогает только определенным типам запросов.
3.  **Каждый индекс имеет стоимость:** Замедляет `INSERT/UPDATE/DELETE`.
4.  **Статистика важна не меньше индексов:** Без актуальной статистики оптимизатор не сможет правильно выбрать индекс.
5.  **Обслуживание обязательно:** Фрагментированные индексы теряют эффективность.

**Современный подход:** Вместо ручного создания десятков индексов используйте:
- **Автоматическую настройку индексов** (SQL Server 2017+)
- **Индексы, оптимизированные под рабочую нагрузку**
- **Columnstore для аналитики**
- **Фильтрованные индексы для частичных данных**

Помните: **Лучший индекс — тот, который создан для конкретного запроса, основанного на реальной рабочей нагрузке.**