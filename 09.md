### Стандарты структурного языка запросов (в SQL). Новые SQL стандарты и их реализация в промышленных СУБД

Язык SQL, несмотря на свою декларативную природу, является стандартизированным. Стандарты, разрабатываемые совместными комитетами ISO и ANSI, задают общее направление развития, но каждая СУБД реализует их с разной степенью полноты и в свои сроки, создавая уникальные диалекты.

---

### **Часть 1. История и основные вехи стандартизации SQL**

| **Стандарт** | **Официальное название** | **Ключевая историческая роль** | **Уровни соответствия** |
| :--- | :--- | :--- | :--- |
| **SQL-86 / SQL-87** | ANSI X3.135-1986, ISO 9075:1987 | **Первый официальный стандарт.** Закрепил базовый синтаксис `SELECT`, `INSERT`, `UPDATE`, `DELETE`, простые подзапросы, `CREATE TABLE`. Был крайне минималистичным. | — |
| **SQL-89** | ANSI X3.135-1989 | **Незначительные уточнения.** Добавлена поддержка ограничений целостности (`PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`), но без каскадных операций. | **FIPS 127-1** ввел уровни соответствия. |
| **SQL-92 / SQL2** | ISO/IEC 9075:1992 | **Величайшая веха, «основа основ».** Значительно расширил язык. Ввел уровни соответствия: **Entry**, **Intermediate**, **Full**. Большинство современных СУБД поддерживают как минимум Entry Level SQL-92. | **Entry:** Базовый синтаксис. <br> **Intermediate:** `OUTER JOIN`, ограничения целостности, `ALTER TABLE`, `DROP TABLE`. <br> **Full:** Временные таблицы, `DOMAIN`, `CAST`. |
| **SQL:1999 / SQL3** | ISO/IEC 9075:1999 | **Смена парадигмы: объектно-реляционные расширения.** Разделение на **Part 1 (Framework)** и **Part 2 (Foundation)**. Первый крупный стандарт после SQL-92. | Ввел понятие **Core** (ядро) и дополнительные пакеты (**Packages**). |
| **SQL:2003** | ISO/IEC 9075:2003 | **Фокус на XML и расширенные типы данных.** | Добавил части **13 (SQL Routines)** и **14 (SQL/XML)**. |
| **SQL:2006** | ISO/IEC 9075:2006 | **Углубленная интеграция с XML.** Определил, как использовать XQuery в SQL (`XMLQuery`). | |
| **SQL:2008** | ISO/IEC 9075:2008 | **OLAP-функции и улучшения DML.** | |
| **SQL:2011** | ISO/IEC 9075:2011 | **Временные данные и улучшенная оконная аналитика.** | |
| **SQL:2016** | ISO/IEC 9075:2016 | **JSON, полиморфные табличные функции, строковые шаблоны.** | |
| **SQL:2023** | ISO/IEC 9075:2023 | **Графовые запросы (SQL/PGQ), Property Graph, `MERGE` улучшения.** Самый свежий стандарт. | |

---

### **Часть 2. Ключевые нововведения современных стандартов SQL (начиная с SQL:1999)**

#### **SQL:1999 — Объектно-реляционная революция**
*   **Рекурсивные запросы (`WITH RECURSIVE`):** Ключевая возможность для работы с иерархическими данными (деревьями, графами).
*   **Оконные функции (`OVER()`):** Аналитические вычисления без свертки строк (`RANK()`, `ROW_NUMBER()`, `SUM() OVER(PARTITION BY ...)`).
*   **Триггеры:** Стандартизация реактивной логики (`CREATE TRIGGER`).
*   **Пользовательские функции и процедуры:** `CREATE FUNCTION`, `CREATE PROCEDURE`.
*   **Большие объекты (LOB):** `BLOB`, `CLOB`.
*   **Типы, определяемые пользователем (UDT):** Поддержка объектно-ориентированных структур.

#### **SQL:2003 — XML и новые типы**
*   **Типы, связанные с XML:** `XML`, функции `XMLSerialize`, `XMLParse`.
*   **Автоинкрементные столбцы (`GENERATED ALWAYS AS IDENTITY`):** Стандартная альтернатива `AUTO_INCREMENT`.
*   **Тип `BOOLEAN`.**
*   **Расширенный `MERGE` (`UPSERT`):** Операция "вставить или обновить".

#### **SQL:2008 — Улучшения для аналитики и удобства**
*   **Улучшенные оконные функции:** `NTH_VALUE`, `LEAD`, `LAG`.
*   **`INSTEAD OF` триггеры для представлений.**
*   **`FETCH` с `OFFSET`:** Стандартизация пагинации (альтернатива нестандартному `LIMIT`).
*   **`TRUNCATE TABLE`:**
*   **Расширенный `CASE`:**

#### **SQL:2011 — Временные (темпоральные) базы данных**
*   **Системное время и время приложения:** `PERIOD FOR SYSTEM_TIME`, `PERIOD FOR APPLICATION_TIME`.
*   **Запросы к истории данных:** `FOR SYSTEM_TIME AS OF`, `BETWEEN` для темпоральных запросов. Позволяет "спросить, как данные выглядели в прошлом".

#### **SQL:2016 — JSON и полиморфизм**
*   **Встроенная поддержка JSON:** Тип данных `JSON`, функции `JSON_OBJECT`, `JSON_ARRAY`, `JSON_QUERY`, `JSON_VALUE`.
*   **Функции для работы с датами и строками:** `LISTAGG` (агрегация строк), расширенные функции для дат.
*   **Полиморфные табличные функции (PTF):** Функции, возвращающие разную структуру таблицы в зависимости от входных аргументов.

#### **SQL:2023 — Графовые запросы и новые структуры**
*   **SQL/PGQ (Property Graph Queries):** Новый раздел стандарта для работы со графами. Вводит конструкции для создания графов (`CREATE PROPERTY GRAPH`) и выполнения графовых запросов (`PATH`, `MATCH`).
*   **Улучшения `MERGE`:** Новые предложения, например, `WHEN NOT MATCHED BY SOURCE THEN DELETE`.
*   **Новые типы данных:** `BINARY`, `VARBINARY` с явным размером.

---

### **Часть 3. Реализация стандартов в промышленных СУБД и последствия**

Ни одна СУБД не реализует стандарт **полностью**. Каждый вендор выбирает свой путь: **PostgreSQL** стремится к максимальному соответствию, **Oracle** и **MS SQL Server** вводят собственные мощные расширения, **MySQL** фокусируется на простоте и покрытии наиболее востребованных функций.

| **Функция / Стандарт** | **PostgreSQL** | **Oracle Database** | **Microsoft SQL Server** | **MySQL** | **Комментарий** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`WITH RECURSIVE` (SQL:1999)** | ✅ Полная поддержка | ✅ (с 11g R2) | ✅ | ✅ (с 8.0) | Ключевая для иерархий. |
| **Оконные функции (SQL:1999, 2003)** | ✅ Очень полная (включая `RANGE`/`GROUPS`) | ✅ Полная с расширениями | ✅ Полная с расширениями (`FIRST_VALUE`, `LAST_VALUE`) | ✅ Базовые с 8.0, улучшается | Стали *де-факто* стандартом для аналитики. |
| **Тип `BOOLEAN` (SQL:1999)** | ✅ Нативный тип `BOOL` | ❌ (использует `NUMBER(1)`) | ✅ (с SQL Server 2005) | ✅ (псевдотип, `TINYINT(1)`) | Различия в хранении и логике. |
| **`MERGE` (SQL:2003)** | ✅ (с 9.5, ранее `UPSERT` через `ON CONFLICT`) | ✅ Полная с расширениями | ✅ Полная с расширениями | ✅ (с 8.0) | PostgreSQL `ON CONFLICT` — мощная нестандартная альтернатива. |
| **Темпоральные таблицы (SQL:2011)** | ✅ (системные версии через расширения, не полностью стандарт) | ✅ Полная поддержка с 12c | ✅ Полная поддержка с SQL Server 2016 | ❌ (только симуляция) | Oracle и MS SQL реализуют близко к стандарту. |
| **Поддержка JSON (SQL:2016)** | ✅ **Ведущая.** Богатый набор функций и индексов (`GIN`), тип `jsonb`. | ✅ (с 12c), тип `JSON`, SQL и path-функции. | ✅ (с 2016), функции `JSON_VALUE`, `OPENJSON`, индексы. | ✅ (с 5.7), тип `JSON`, функции, индексы (виртуальные). | **PostgreSQL `jsonb`** считается эталоном по производительности и возможностям. |
| **Графовые запросы (SQL:2023)** | ⚠️ **Экспериментально** (расширение `age`). Не по стандарту PGQ. | ✅ **Собственный стандарт!** `GRAPH` в 23c (модель RDF и Property Graph). | ⚠️ Частично через `SQL Server Graph` (с 2017). Собственный синтаксис (`MATCH`). | ❌ | **Oracle первой заявила о поддержке SQL:2023 PGQ.** Остальные используют свои подходы. |
| **Строковая агрегация `LISTAGG` (SQL:2016)** | ✅ (с 9.0 как `string_agg`, стандартный `LISTAGG` с 15?) | ✅ (родной `LISTAGG` с 11g R2) | ✅ (через `STRING_AGG` с 2017) | ❌ (используется `GROUP_CONCAT`) | Классический пример, когда стандарт закрепляет уже устоявшуюся практику (`GROUP_CONCAT` в MySQL был раньше). |

---

### **Практические последствия частичной поддержки стандартов**

1.  **Проблема переносимости (Portability):** Написав запрос для PostgreSQL, вы не можете быть уверены, что он заработает на Oracle без изменений. Это приводит к:
    *   **Дополнительным затратам** при миграции между СУБД.
    *   **Привязке к вендору (Vendor Lock-in)**, особенно при использовании уникальных расширений (например, `CONNECT BY` в Oracle, `T-SQL` в MS SQL).
    *   **Необходимости использования ORM или абстрактных слоев доступа к данным**, которые пытаются сгладить различия (часто ценой потери производительности).

2.  **Развитие через инновации и конкуренцию:** Именно **отклонения от стандарта** часто становятся главными преимуществами СУБД:
    *   **PostgreSQL:** Расширяемость (расширения), типы данных `jsonb`, `array`, мощная геопространственная поддержка (PostGIS).
    *   **Oracle:** Масштабируемость (RAC), аппаратное ускорение (Exadata), уникальные оптимизации для PL/SQL.
    *   **MS SQL Server:** Глубокая интеграция с экосистемой Microsoft (.NET, Active Directory), columnstore-индексы для аналитики.
    *   **MySQL:** Простота, репликация, вставка в память (MemSQL).

3.  **Стандарт как общий ориентир:** Несмотря на различия, стандарты выполняют критически важные функции:
    *   **Задают общую терминологию и концепции.**
    *   **Определяют "ожидаемое поведение"**, к которому стремятся все.
    *   **Служат фундаментом** для обучения и документации.

**Вывод для разработчика:**
1.  **Начинайте со стандартного SQL,** где это возможно (`JOIN` вместо старых запятых, оконные функции). Это повысит читаемость и потенциальную переносимость.
2.  **Изучайте диалект вашей целевой СУБД** досконально. Его уникальные расширения — это ключ к максимальной производительности и выразительности.
3.  **Относитесь к стандарту как к словарю общего языка,** но помните, что в каждом "регионе" (СУБД) есть свои диалекты и идиомы, без знания которых нельзя стать экспертом.