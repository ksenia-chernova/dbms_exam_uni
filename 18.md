### Уровни изолированности. Принципы ACID

### **Часть 1. Принципы ACID**

**Транзакция** — это логическая единица работы с базой данных, которая либо выполняется полностью, либо не выполняется вовсе. Принципы ACID — это четыре фундаментальных свойства, которые гарантируют надежность транзакций.

#### **A — Atomicity (Атомарность)**

**Определение:** Транзакция является **неделимой** единицей работы — либо выполняются **все** её операции, либо не выполняется **ни одна**.

**Реализация:**
- Механизм **отката (ROLLBACK)** через журнал транзакций (WAL)
- Контрольные точки (checkpoints)
- **Пример:** Перевод денег между счетами
  ```sql
  BEGIN TRANSACTION;
    UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
    UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2;
  COMMIT; -- Атомарно обе операции
  ```

#### **C — Consistency (Согласованность)**

**Определение:** Транзакция переводит базу данных из **одного согласованного состояния в другое**. Все ограничения целостности (PK, FK, CHECK) должны выполняться.

**Реализация:**
- Проверка ограничений в конце транзакции
- Каскадные операции внешних ключей
- **Пример:** Нельзя добавить заказ несуществующему клиенту
  ```sql
  -- Если CustomerID = 999 не существует, транзакция откатится
  INSERT INTO Orders (OrderID, CustomerID) VALUES (1001, 999);
  ```

#### **I — Isolation (Изолированность)**

**Определение:** Параллельно выполняемые транзакции **не должны влиять** друг на друга. Результат параллельного выполнения должен быть эквивалентен последовательному.

**Реализация:**
- Механизмы блокировок (locks)
- Многовариантное управление параллелизмом (MVCC)
- Уровни изоляции

#### **D — Durability (Устойчивость)**

**Определение:** После завершения транзакции (COMMIT) её изменения **гарантированно сохраняются** даже при сбое оборудования.

**Реализация:**
- Журнал транзакций (Write-Ahead Logging)
- Синхронная запись журнала на диск перед COMMIT
- Репликация данных

```
[Транзакция начинается]
     |
     v
Атомарность → Все или ничего
     |
     v
Согласованность → Соответствие правилам
     |
     v
Изолированность → Независимость от других транзакций
     |
     v
Устойчивость → Гарантированное сохранение
```

---

### **Часть 2. Проблемы параллельного доступа**

При одновременном выполнении транзакций возникают проблемы, которые нарушают изоляцию.

#### **2.1. Dirty Read (Грязное чтение)**

**Проблема:** Чтение **незафиксированных** изменений другой транзакции, которая может быть откатана.

```
Транзакция A: UPDATE Users SET Balance = 500 WHERE ID = 1; -- Не зафиксировано
Транзакция B: SELECT Balance FROM Users WHERE ID = 1;      -- Читает 500 (грязные данные!)
Транзакция A: ROLLBACK; -- Откат
Транзакция B: Считала несуществующие данные
```

#### **2.2. Non-repeatable Read (Неповторяющееся чтение)**

**Проблема:** В рамках одной транзакции повторное чтение одних и тех же данных дает **разные результаты** из-за UPDATE другой транзакции.

```
Транзакция A: SELECT Balance FROM Users WHERE ID = 1; -- Читает 100
Транзакция B: UPDATE Users SET Balance = 200 WHERE ID = 1; COMMIT;
Транзакция A: SELECT Balance FROM Users WHERE ID = 1; -- Читает 200 (изменилось!)
```

#### **2.3. Phantom Read (Фантомное чтение)**

**Проблема:** Появление **новых строк** (фантомов) при повторном выполнении запроса с тем же условием из-за INSERT другой транзакции.

```
Транзакция A: SELECT COUNT(*) FROM Orders WHERE Status = 'Pending'; -- 5
Транзакция B: INSERT INTO Orders (Status) VALUES ('Pending'); COMMIT;
Транзакция A: SELECT COUNT(*) FROM Orders WHERE Status = 'Pending'; -- 6 (появился фантом)
```

#### **2.4. Lost Update (Потерянное обновление)**

**Проблема:** Две транзакции читают одну строку, обе изменяют её, последний COMMIT перезаписывает изменения первого.

```
-- Классический пример с инкрементом
Транзакция A: Читает баланс = 100
Транзакция B: Читает баланс = 100
Транзакция A: Пишет баланс = 100 + 50 = 150
Транзакция B: Пишет баланс = 100 + 30 = 130 (потеряла +50 от A!)
```

---

### **Часть 3. Уровни изоляции транзакций**

Уровень изоляции определяет, **какие проблемы параллельного доступа допускаются** в обмен на производительность.

#### **3.1. Стандартные уровни изоляции (ANSI/ISO SQL)**

| Уровень | Dirty Read | Non-repeatable Read | Phantom Read | Потерянное обновление |
| :--- | :---: | :---: | :---: | :---: |
| **READ UNCOMMITTED** | ✅ Разрешено | ✅ Разрешено | ✅ Разрешено | ✅ Возможно |
| **READ COMMITTED** | ❌ Запрещено | ✅ Разрешено | ✅ Разрешено | ❌ Запрещено* |
| **REPEATABLE READ** | ❌ Запрещено | ❌ Запрещено | ✅ Разрешено | ❌ Запрещено |
| **SERIALIZABLE** | ❌ Запрещено | ❌ Запрещено | ❌ Запрещено | ❌ Запрещено |

*В SQL Server READ COMMITTED предотвращает потерю обновлений через блокировки.

#### **3.2. Расширенные уровни в SQL Server**

**READ COMMITTED SNAPSHOT (RCSI) и SNAPSHOT:**
- Используют **MVCC (Multi-Version Concurrency Control)**
- Читающие транзакции видят **снимок (snapshot)** данных на момент начала
- Писающие транзакции работают с актуальными данными
- **Нет блокировок для чтения** (улучшение параллелизма)

#### **3.3. Синтаксис установки уровня изоляции**

```sql
-- Для всей сессии
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- Для конкретной транзакции
BEGIN TRANSACTION;
    SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
    -- Операции...
COMMIT;

-- Указание в запросе (SQL Server 2019+)
SELECT * FROM Orders 
WITH (SNAPSHOT) 
WHERE OrderID = 12345;
```

#### **3.4. Механизмы реализации**

**1. Блокировки (Locking):**
- **Разделяемые (Shared, S):** Для чтения, несколько транзакций могут иметь одновременно
- **Монопольные (Exclusive, X):** Для записи, только одна транзакция
- **Обновляемые (Update, U):** Для потенциального обновления
- **Намеренные (Intent):** На уровне таблицы или страницы

**2. Многовариантное управление параллелизмом (MVCC):**
- Хранение **нескольких версий** строк в `tempdb` (SQL Server) или в самой таблице (PostgreSQL)
- Чтение видит **консистентный снимок** на момент начала операции
- Автоматическая очистка старых версий

---

### **Часть 4. Подробная характеристика каждого уровня**

#### **4.1. READ UNCOMMITTED (Чтение незафиксированных данных)**

**Поведение:** Позволяет читать данные, которые изменяются другими транзакциями и ещё не зафиксированы.

**Реализация в SQL Server:** Использует **подсказку NOLOCK**.
```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- Или
SELECT * FROM Orders WITH (NOLOCK);
```

**Плюсы:**
- Максимальная производительность
- Нет блокировок на чтение

**Минусы:**
- Грязное чтение
- Несогласованные данные

**Когда использовать:** Только для статистики, отчетов, где точность не критична.

#### **4.2. READ COMMITTED (Чтение зафиксированных данных) — ПО УМОЛЧАНИЮ**

**Поведение:** Чтение только зафиксированных данных. Другие транзакции не могут изменить читаемые данные до конца чтения.

**Реализация:** Блокировки или RCSI.

**Пример проблемы:**
```sql
-- Транзакция 1
BEGIN TRANSACTION;
UPDATE Accounts SET Balance = Balance + 100 WHERE ID = 1;
-- Блокировка строки ID=1 (Exclusive lock)

-- Транзакция 2 (другой сессии)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT Balance FROM Accounts WHERE ID = 1; 
-- Будет ЖДАТЬ, пока транзакция 1 не завершится (COMMIT/ROLLBACK)
```

**READ COMMITTED SNAPSHOT (RCSI):**
```sql
-- Включение на уровне базы данных
ALTER DATABASE MyDB SET READ_COMMITTED_SNAPSHOT ON;

-- Теперь при READ COMMITTED используется MVCC
-- Транзакция 2 прочитает старую версию из tempdb, не будет ждать
```

#### **4.3. REPEATABLE READ (Повторяемое чтение)**

**Поведение:** Гарантирует, что строки, прочитанные в транзакции, не будут изменены другими транзакциями до её завершения.

**Реализация:** Удерживает разделяемые блокировки на прочитанных строках до конца транзакции.

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN TRANSACTION;
    SELECT Balance FROM Accounts WHERE ID = 1; -- Блокировка S на строке
    -- Другая транзакция НЕ МОЖЕТ изменить эту строку
    SELECT Balance FROM Accounts WHERE ID = 1; -- Гарантированно то же значение
COMMIT; -- Блокировки снимаются
```

**Проблема:** Не предотвращает фантомы. Другая транзакция может вставить новую строку, удовлетворяющую условию.

#### **4.4. SERIALIZABLE (Сериализуемый)**

**Поведение:** Самая строгая изоляция. Транзакции выполняются так, как будто они выполняются **последовательно**, одна за другой.

**Реализация:** Блокировки диапазонов (range locks) или MVCC с сериализуемыми снимками.

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
    SELECT COUNT(*) FROM Orders WHERE Status = 'Pending';
    -- Блокировка диапазона на Status = 'Pending'
    -- Другая транзакция НЕ МОЖЕТ вставить новую строку с таким Status
COMMIT;
```

**SNAPSHOT (в SQL Server):**
```sql
ALTER DATABASE MyDB SET ALLOW_SNAPSHOT_ISOLATION ON;

SET TRANSACTION ISOLATION LEVEL SNAPSHOT;
BEGIN TRANSACTION;
    -- Видит снимок данных на момент начала транзакции
    -- Если другая транзакция изменит данные, текущая получит ошибку
COMMIT;
```

---

### **Часть 5. Влияние на производительность и рекомендации**

#### **Матрица производительности/согласованности:**

```
Высокая производительность ←-----→ Высокая согласованность
READ UNCOMMITTED --- READ COMMITTED --- REPEATABLE READ --- SERIALIZABLE
      ↑                      ↑                      ↑               ↑
   Меньше                Больше                 Больше         Максимум
 блокировок           параллелизма            согласованности   изоляции
```

#### **Рекомендации по выбору уровня изоляции:**

1.  **Финансовые операции (банкинг):** SERIALIZABLE или REPEATABLE READ
2.  **OLTP-системы (заказы, CRM):** READ COMMITTED (лучше RCSI)
3.  **Отчеты, аналитика:** READ UNCOMMITTED или SNAPSHOT
4.  **Системы с высокой конкуренцией:** READ COMMITTED SNAPSHOT
5.  **Операции массовой обработки:** READ COMMITTED с ручными блокировками

#### **Проблемы высоких уровней изоляции:**

1.  **Взаимоблокировки (Deadlocks):**
    ```sql
    -- Транзакция A
    UPDATE Table1 SET ... WHERE ID = 1;
    UPDATE Table2 SET ... WHERE ID = 2;
    
    -- Транзакция B (параллельно)
    UPDATE Table2 SET ... WHERE ID = 2;
    UPDATE Table1 SET ... WHERE ID = 1; -- DEADLOCK!
    ```

2.  **Блокировки (Locks):** SERIALIZABLE может блокировать большие диапазоны данных.

3.  **Ошибка 3960 в SNAPSHOT:** "Snapshot isolation transaction failed in database...". Возникает, когда транзакция пытается изменить данные, которые уже изменились.

#### **Практические примеры:**

**Пример 1: Банковский перевод (максимальная надежность)**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
    DECLARE @amount DECIMAL(10,2) = 100.00;
    
    -- Проверка баланса с блокировкой
    SELECT Balance FROM Accounts WITH (UPDLOCK) 
    WHERE AccountID = 1 AND Balance >= @amount;
    
    -- Если баланса достаточно
    UPDATE Accounts SET Balance = Balance - @amount WHERE AccountID = 1;
    UPDATE Accounts SET Balance = Balance + @amount WHERE AccountID = 2;
    
    INSERT INTO Transactions (...) VALUES (...);
    
    IF @@ERROR = 0
        COMMIT;
    ELSE
        ROLLBACK;
```

**Пример 2: Отчет (максимальная производительность)**
```sql
-- Для отчетов, где не нужна абсолютная точность
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT 
    CustomerID,
    COUNT(*) AS OrderCount,
    SUM(TotalAmount) AS TotalSales
FROM Orders WITH (NOLOCK)
WHERE OrderDate >= '2024-01-01'
GROUP BY CustomerID;
```

**Пример 3: Балансировка производительности и точности**
```sql
-- Включение RCSI для всей базы
ALTER DATABASE MyAppDB 
SET READ_COMMITTED_SNAPSHOT ON 
WITH ROLLBACK IMMEDIATE;

-- Теперь все транзакции с READ COMMITTED используют MVCC
-- Нет блокировок на чтение, но нет и грязного чтения
```

---

### **6. Современные тенденции**

1.  **MVCC вместо блокировок:** PostgreSQL, Oracle, SQL Server (RCSI)
2.  **Оптимистическая блокировка:** Версионирование строк, проверка при коммите
3.  **Гибридные подходы:** Разные уровни для разных частей приложения
4.  **Распределенные транзакции:** 2PC, Saga pattern для микросервисов

---

### **3. Заключение**

**Уровни изоляции — это компромисс между:**
- **Согласованностью данных** (точность)
- **Параллелизмом** (производительность)
- **Надежностью** (отсутствие ошибок)

**Ключевые выводы:**

1.  **По умолчанию используйте READ COMMITTED** (лучше с RCSI) — баланс для большинства приложений.
2.  **SERIALIZABLE — дорого,** используйте только когда действительно необходимо.
3.  **READ UNCOMMITTED опасен,** но может быть полезен для отчетности.
4.  **Понимайте механизмы:** Блокировки vs MVCC.
5.  **Тестируйте под нагрузкой:** Уровень изоляции может кардинально влиять на производительность.
6.  **Мониторьте deadlocks и блокировки:** Они неизбежны при высоких уровнях изоляции.

**Помните:** Не существует "лучшего" уровня изоляции. Есть только **подходящий для вашей конкретной рабочей нагрузки и требований к данным.** Выбор уровня изоляции — это архитектурное решение, которое влияет на всю систему.