### Синонимы, ключи, ограничения целостности, умолчания, правила

### **Часть 1. Синонимы (Synonyms)**

**Синоним (Synonym)** — это объект базы данных, который служит **альтернативным именем** для другого объекта (таблицы, представления, хранимой процедуры, функции, сборки).

#### **Назначение и преимущества:**
1.  **Абстракция от расположения:** Позволяют создать локальное имя для объекта, который может находиться:
    *   В другой схеме той же базы (`dbo.Employees` → `hr.Emp`)
    *   В другой базе данных на том же сервере (`AdventureWorks.HR.Employees` → `hr.AllEmployees`)
    *   На другом сервере (`LinkedServer.AdventureWorks.dbo.Products` → `RemoteProducts`)
2.  **Упрощение миграции:** При переносе объектов можно изменить синоним, не меняя код приложений.
3.  **Сокращение кода:** Для длинных имен (особенно с четырехкомпонентной нотацией).
4.  **Слой совместимости:** Можно переименовать таблицу, а старый доступ оставить через синоним.

#### **Типы синонимов:**
*   **Локальный:** Существует в конкретной базе данных.
*   **Частный vs публичный:** 
    *   **Частный (по умолчанию):** Доступен только владельцу.
    *   **Публичный (`PUBLIC`):** Доступен всем пользователям базы данных.

#### **Синтаксис и примеры:**
```sql
-- Создание синонима
CREATE [ OR ALTER ] SYNONYM [schema_name.]synonym_name 
FOR [server_name.][database_name.][schema_name.]object_name;

-- Примеры:
-- 1. Синоним для таблицы в другой схеме
CREATE SYNONYM dbo.Emp FOR hr.Employees;

-- 2. Синоним для таблицы в другой базе
CREATE SYNONYM Prod FOR AdventureWorks.Production.Product;

-- 3. Синоним для удаленного объекта (через связанный сервер)
CREATE SYNONYM RemoteOrders FOR LinkedServer.AdventureWorks.Sales.Orders;

-- 4. Публичный синоним
CREATE PUBLIC SYNONYM AllProducts FOR dbo.Products;

-- Использование (как обычная таблица)
SELECT * FROM dbo.Emp;
SELECT * FROM RemoteOrders;

-- Управление синонимами
DROP SYNONYM IF EXISTS dbo.Emp;
EXEC sp_rename 'dbo.OldSynonym', 'NewSynonym';  -- Переименование
```

#### **Ограничения:**
*   Синоним не может ссылаться на другой синоним.
*   Нельзя использовать в DDL-операциях (`ALTER`, `DROP` исходного объекта).
*   Не поддерживаются для объектов в `tempdb`.

---

### **Часть 2. Ключи и ограничения целостности**

**Ограничение целостности (Constraint)** — это правило, которое СУБД автоматически применяет для поддержания корректности и согласованности данных.

#### **2.1. Первичный ключ (`PRIMARY KEY`)**
*   **Назначение:** Однозначно идентифицирует каждую строку в таблице.
*   **Свойства:**
    *   Значения **уникальны** во всей таблице.
    *   Не может содержать `NULL` значений.
    *   В таблице может быть только **один** первичный ключ (но он может быть составным из нескольких столбцов).
    *   Автоматически создает **кластеризованный индекс** (если явно не указано `NONCLUSTERED`).
*   **Синтаксис:**
    ```sql
    -- Вариант 1: В определении столбца
    CREATE TABLE Employees (
        EmployeeID INT PRIMARY KEY,  -- Кластеризованный PK
        LastName NVARCHAR(50)
    );
    
    -- Вариант 2: Отдельное ограничение (лучше для составных ключей)
    CREATE TABLE OrderDetails (
        OrderID INT,
        ProductID INT,
        Quantity INT,
        CONSTRAINT PK_OrderDetails PRIMARY KEY (OrderID, ProductID)
    );
    
    -- Вариант 3: Добавление к существующей таблице
    ALTER TABLE Employees
    ADD CONSTRAINT PK_Employees PRIMARY KEY (EmployeeID);
    ```

#### **2.2. Внешний ключ (`FOREIGN KEY`)**
*   **Назначение:** Обеспечивает **ссылочную целостность** между таблицами. Значение в столбце должно существовать в связанной таблице.
*   **Свойства:**
    *   Ссылается на `PRIMARY KEY` или `UNIQUE` ограничение другой (или той же) таблицы.
    *   Может содержать `NULL` значения (если не запрещено `NOT NULL`).
*   **Каскадные операции:**
    ```sql
    CREATE TABLE Orders (
        OrderID INT PRIMARY KEY,
        CustomerID INT,
        OrderDate DATE,
        CONSTRAINT FK_Orders_Customers 
            FOREIGN KEY (CustomerID) 
            REFERENCES Customers(CustomerID)
            ON DELETE CASCADE     -- При удалении клиента удаляются его заказы
            ON UPDATE NO ACTION   -- Запрет изменения ID клиента (по умолчанию)
    );
    ```
*   **Варианты действий:**
    *   `NO ACTION` / `RESTRICT` — запрет операции (по умолчанию).
    *   `CASCADE` — каскадное выполнение той же операции.
    *   `SET NULL` — установить `NULL` в зависимых строках.
    *   `SET DEFAULT` — установить значение по умолчанию.

---

### **Часть 3. Ограничения `CHECK`, `UNIQUE`, `NOT NULL`**

#### **3.1. Ограничение `CHECK`**
*   **Назначение:** Проверка значений по условию (доменная целостность).
*   **Может проверять:** значения столбца, значения нескольких столбцов, вызывать функции.
```sql
-- Проверка на уровне столбца
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Salary DECIMAL(10,2) CHECK (Salary > 0),  -- Зарплата > 0
    HireDate DATE,
    BirthDate DATE,
    -- Проверка на уровне таблицы (между столбцами)
    CONSTRAINT CHK_Dates CHECK (HireDate > BirthDate)
);

-- Сложная проверка с функцией
ALTER TABLE Products
ADD CONSTRAINT CHK_ProductCode 
    CHECK (ProductCode LIKE '[A-Z][A-Z][0-9][0-9][0-9]');
```

#### **3.2. Ограничение `UNIQUE`**
*   **Назначение:** Гарантирует уникальность значений в столбце или группе столбцов.
*   **Отличие от `PRIMARY KEY`:** Допускает один `NULL` (в SQL Server) или несколько `NULL` (в других СУБД).
*   **Создает некластеризованный индекс.**
```sql
CREATE TABLE Users (
    UserID INT PRIMARY KEY,
    Email NVARCHAR(100) UNIQUE,  -- Уникальный email
    Username NVARCHAR(50) NOT NULL
);

-- Составное уникальное ограничение
ALTER TABLE CourseRegistrations
ADD CONSTRAINT UQ_Student_Course 
    UNIQUE (StudentID, CourseID, Semester);
```

#### **3.3. Ограничение `NOT NULL`**
*   **Назначение:** Запрещает `NULL` значения в столбце.
*   **Особенность:** Это не совсем ограничение в классическом смысле, а свойство столбца.
```sql
CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CompanyName NVARCHAR(100) NOT NULL,  -- Обязательное поле
    ContactName NVARCHAR(100),           -- Может быть NULL
    Phone NVARCHAR(20) NOT NULL
);
```

---

### **Часть 4. Умолчания (DEFAULT) и правила (RULES)**

#### **4.1. Умолчания (DEFAULT значения)**
*   **Назначение:** Задает значение по умолчанию для столбца при `INSERT`, если значение не указано явно.
*   **Может быть:** Константой, системной функцией, выражением.
```sql
-- Вариант 1: При создании таблицы
CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    OrderDate DATE DEFAULT GETDATE(),      -- Текущая дата
    Status NVARCHAR(20) DEFAULT 'Pending', -- Константа
    TotalAmount DECIMAL(10,2) DEFAULT 0
);

-- Вариант 2: Добавление к существующей таблице
ALTER TABLE Employees
ADD CreateDate DATETIME DEFAULT GETDATE();

-- Вариант 3: Именованное ограничение DEFAULT
ALTER TABLE Products
ADD CONSTRAINT DF_Products_ModifiedDate 
    DEFAULT GETDATE() FOR ModifiedDate;

-- Использование: если не указать значение, будет использовано умолчание
INSERT INTO Orders (OrderID) VALUES (1);  -- OrderDate = GETDATE(), Status = 'Pending'
```

#### **4.2. Правила (RULES) — устаревший объект**
*   **Назначение:** Аналогично ограничению `CHECK`, но создается как отдельный объект и затем привязывается к столбцам или типам данных.
*   **Статус:** **Устарели (deprecated)** в SQL Server. Поддерживаются только для обратной совместимости. Используйте `CHECK` вместо них.

```sql
-- Создание правила (старый синтаксис)
CREATE RULE SalaryRule 
    AS @Salary > 0 AND @Salary < 1000000;

-- Привязка правила к столбцу
EXEC sp_bindrule 'SalaryRule', 'Employees.Salary';

-- Отвязка правила
EXEC sp_unbindrule 'Employees.Salary';

-- Просмотр правил
SELECT * FROM sys.objects WHERE type = 'R';
```

**Почему правила устарели:**
1.  Менее производительны, чем `CHECK`.
2.  Сложнее в управлении (отдельные объекты).
3.  Не переносимы между СУБД.
4.  Современная альтернатива — пользовательские типы данных с ограничениями.

---

### **Сводная таблица механизмов целостности**

| **Механизм** | **Тип целостности** | **Назначение** | **Пример** |
| :--- | :--- | :--- | :--- |
| **`PRIMARY KEY`** | Сущностная | Уникальная идентификация строк | `EmployeeID INT PRIMARY KEY` |
| **`FOREIGN KEY`** | Ссылочная | Связь между таблицами | `FOREIGN KEY (DeptID) REFERENCES Departments(ID)` |
| **`UNIQUE`** | Сущностная | Уникальность (кроме NULL) | `Email NVARCHAR(100) UNIQUE` |
| **`CHECK`** | Доменная | Проверка по условию | `CHECK (Age >= 18)` |
| **`NOT NULL`** | Доменная | Запрет NULL значений | `Name NVARCHAR(50) NOT NULL` |
| **`DEFAULT`** | Доменная | Значение по умолчанию | `CreatedDate DATETIME DEFAULT GETDATE()` |
| **`RULES`** | Доменная | Устаревший аналог `CHECK` | **Не использовать!** |

---

### **3. Заключение и лучшие практики**

#### **Роль синонимов:**
*   **Стратегический инструмент** для абстракции и упрощения миграции.
*   Используйте для длинных имен, ссылок на удаленные объекты.
*   Избегайте избыточного создания — могут усложнить понимание схемы.

#### **Роль ограничений целостности:**
*   **Фундаментальный механизм** обеспечения качества данных.
*   **Всегда предпочитайте декларативные ограничения** (`PRIMARY KEY`, `FOREIGN KEY`, `CHECK`) процедурной логике (триггеры, процедуры).
*   **Принцип:** "Доверяй, но проверяй" — СУБД сделает это за вас.

#### **Рекомендации по использованию:**

1.  **Всегда создавайте `PRIMARY KEY`** для таблиц (даже если это суррогатный ключ).
2.  **Используйте `FOREIGN KEY`** для явного указания связей (документирование схемы + целостность).
3.  **Применяйте `CHECK`** для бизнес-правил (`Salary > 0`, `Email LIKE '%@%'`).
4.  **Именуйте все ограничения** явно (лучше сопровождение):
    ```sql
    -- ПЛОХО
    CREATE TABLE T (ID INT PRIMARY KEY);
    
    -- ХОРОШО
    CREATE TABLE T (
        ID INT CONSTRAINT PK_T_ID PRIMARY KEY,
        Value INT CONSTRAINT CK_T_Value CHECK (Value > 0)
    );
    ```
5.  **Проверяйте существование** перед созданием/удалением:
    ```sql
    ALTER TABLE Employees
    DROP CONSTRAINT IF EXISTS CK_Salary;
    
    IF NOT EXISTS (SELECT * FROM sys.objects WHERE name = 'PK_Employees')
    BEGIN
        ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY (ID);
    END
    ```

**Итог:** Комбинация синонимов (для гибкости доступа) и декларативных ограничений (для гарантии целостности) образует **профессиональный фундамент** надежной и сопровождаемой базы данных. Правила (`RULES`) должны быть полностью исключены из современных разработок.