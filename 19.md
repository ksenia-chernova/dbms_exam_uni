### Понятие транзакции в СУБД. Изоляция транзакций. Блокировки и уровни изоляции транзакций. Применение журнала транзакций для защиты и восстановления БД

### **Часть 1. Понятие транзакции и свойства ACID**

**Транзакция** — это логическая единица работы с базой данных, которая должна быть выполнена **атомарно, согласованно, изолированно и устойчиво**.

#### **Формальное определение:**
Транзакция — это последовательность операций чтения/записи, которая:
1.  Начинается с `BEGIN TRANSACTION` (явно или неявно)
2.  Заканчивается `COMMIT` (успех) или `ROLLBACK` (откат)
3.  Выполняется **полностью или не выполняется вовсе**

#### **Свойства ACID в контексте транзакций:**

| Свойство | Описание | Как обеспечивается в SQL Server |
| :--- | :--- | :--- |
| **Atomicity** (Атомарность) | "Все или ничего" | Журнал транзакций (WAL), контрольные точки |
| **Consistency** (Согласованность) | Соответствие бизнес-правилам | Ограничения (PK, FK, CHECK), триггеры |
| **Isolation** (Изоляция) | Независимость параллельных транзакций | Блокировки, MVCC, уровни изоляции |
| **Durability** (Устойчивость) | Сохранение после сбоя | Синхронная запись журнала, репликация |

#### **Пример транзакции:**
```sql
-- Явное управление транзакцией
BEGIN TRANSACTION;  -- Начало

BEGIN TRY
    -- Операции как единое целое
    UPDATE Accounts SET Balance = Balance - 100.00 
    WHERE AccountID = 123;
    
    UPDATE Accounts SET Balance = Balance + 100.00 
    WHERE AccountID = 456;
    
    INSERT INTO Transactions (FromAcc, ToAcc, Amount, Timestamp)
    VALUES (123, 456, 100.00, GETDATE());
    
    -- Если все успешно
    COMMIT TRANSACTION;  -- Фиксация
    PRINT 'Транзакция выполнена успешно';
END TRY
BEGIN CATCH
    -- При ошибке - откат
    ROLLBACK TRANSACTION;
    PRINT 'Ошибка: ' + ERROR_MESSAGE();
    THROW;
END CATCH
```

**Автофиксация (Autocommit):**
```sql
-- Каждая инструкция - отдельная транзакция
INSERT INTO T1 VALUES (1);  -- Автоматический COMMIT
INSERT INTO T2 VALUES (2);  -- Автоматический COMMIT
-- Если вторая инструкция падает, первая УЖЕ зафиксирована
```

---

### **Часть 2. Изоляция транзакций**

#### **2.1. Проблемы параллельного доступа**

| Проблема | Описание | Пример |
| :--- | :--- | :--- |
| **Грязное чтение** (Dirty Read) | Чтение незафиксированных данных | Чтение баланса, который потом откатят |
| **Неповторяющееся чтение** (Non-repeatable Read) | Разные значения при повторном чтении | Баланс изменился между двумя SELECT |
| **Фантомное чтение** (Phantom Read) | Появление новых строк | Новые заказы появились между проверками |
| **Потерянное обновление** (Lost Update) | Перезапись изменений | Два кассира одновременно меняют остаток |

#### **2.2. Уровни изоляции (SQL-стандарт и расширения)**

**Матрица защиты от проблем:**

| Уровень изоляции | Dirty Read | Non-repeatable | Phantom | Lost Update |
| :--- | :---: | :---: | :---: | :---: |
| **READ UNCOMMITTED** | ❌ | ❌ | ❌ | ❌ |
| **READ COMMITTED** (по умолчанию) | ✅ | ❌ | ❌ | ✅* |
| **REPEATABLE READ** | ✅ | ✅ | ❌ | ✅ |
| **SERIALIZABLE** | ✅ | ✅ | ✅ | ✅ |
| **SNAPSHOT** (SQL Server) | ✅ | ✅ | ✅ | ✅ |
| **READ COMMITTED SNAPSHOT** | ✅ | ❌ | ❌ | ✅ |

*В SQL Server предотвращается через блокировки

#### **2.3. Установка уровня изоляции:**

```sql
-- Для сессии
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- Для конкретного запроса (табличные подсказки)
SELECT * FROM Orders WITH (NOLOCK);  -- READ UNCOMMITTED
SELECT * FROM Orders WITH (READCOMMITTEDLOCK); -- С блокировками
SELECT * FROM Orders WITH (REPEATABLEREAD);
```

#### **2.4. MVCC (Multi-Version Concurrency Control) - современный подход**

**Принцип:** Хранение **нескольких версий строк** для разных транзакций.

**В SQL Server:**
- **READ COMMITTED SNAPSHOT (RCSI):** Для уровня READ COMMITTED
- **SNAPSHOT:** Отдельный уровень изоляции

```sql
-- Включение на уровне БД
ALTER DATABASE MyDB SET READ_COMMITTED_SNAPSHOT ON;
ALTER DATABASE MyDB SET ALLOW_SNAPSHOT_ISOLATION ON;

-- Использование
SET TRANSACTION ISOLATION LEVEL SNAPSHOT;
BEGIN TRANSACTION;
    -- Видит снимок данных на момент начала
    SELECT * FROM Orders;
    -- Другие транзакции могут изменять данные
COMMIT;
```

---

### **Часть 3. Механизмы блокировок**

#### **3.1. Типы блокировок по режиму**

| Тип | Обозначение | Назначение | Совместимость |
| :--- | :--- | :--- | :--- |
| **Разделяемая** (Shared) | S | Для операций чтения | Совместима с S, но не с X |
| **Монопольная** (Exclusive) | X | Для операций изменения (INSERT, UPDATE, DELETE) | Не совместима ни с чем |
| **Обновляемая** (Update) | U | Для потенциального обновления | Совместима с S, но не с U/X |
| **Намеренная** (Intent) | IS, IX, SIX | Сигнализирует о намерении заблокировать ресурс нижнего уровня | |

**Матрица совместимости блокировок:**

```
       |  S  |  X  |  U  | IS  | IX  | SIX |
-------|-----|-----|-----|-----|-----|-----|
   S   |  ✓  |  ✗  |  ✓  |  ✓  |  ✗  |  ✗  |
   X   |  ✗  |  ✗  |  ✗  |  ✗  |  ✗  |  ✗  |
   U   |  ✓  |  ✗  |  ✗  |  ✓  |  ✗  |  ✗  |
  IS   |  ✓  |  ✗  |  ✓  |  ✓  |  ✓  |  ✓  |
  IX   |  ✗  |  ✗  |  ✗  |  ✓  |  ✓  |  ✗  |
  SIX  |  ✗  |  ✗  |  ✗  |  ✓  |  ✗  |  ✗  |
```

#### **3.2. Уровни блокировок (гранулярность)**

**Иерархия блокировок (от крупных к мелким):**
```
База данных (Database)
      ↓
Файл/Файловая группа (File/Filegroup)
      ↓
Таблица (Table) / Индекс (Index)
      ↓
Страница (Page) / Экстент (Extent)
      ↓
Строка (Row) / Ключ (Key)
      ↓
Столбец (Column) *очень редко*
```

**Пример блокировок в действии:**
```sql
-- Транзакция 1
BEGIN TRANSACTION;
UPDATE Orders WITH (ROWLOCK)  -- Явное указание уровня
SET Status = 'Processed'
WHERE OrderID = 1001;
-- Удерживает X-блокировку на строке OrderID=1001

-- Транзакция 2 (параллельно)
SELECT * FROM Orders 
WHERE OrderID = 1001;
-- Будет ждать, если уровень изоляции >= READ COMMITTED
-- Получит S-блокировку только после COMMIT транзакции 1
```

#### **3.3. Эскалация блокировок (Lock Escalation)**

**Принцип:** SQL Server автоматически заменяет множество блокировок мелкой гранулярности на одну блокировку крупной гранулярности при превышении порога.

**Пороги:**
- Более 5000 блокировок на один объект
- Или использование >40% памяти для блокировок

**Управление эскалацией:**
```sql
-- Отключение эскалации для таблицы
ALTER TABLE Orders SET (LOCK_ESCALATION = DISABLE);

-- Ограничение уровнем таблицы
ALTER TABLE Orders SET (LOCK_ESCALATION = TABLE);

-- Для конкретной транзакции
BEGIN TRANSACTION;
    SELECT * FROM Orders WITH (TABLOCKX); -- Монопольная блокировка таблицы
COMMIT;
```

#### **3.4. Взаимоблокировки (Deadlocks)**

**Определение:** Ситуация, когда две или более транзакции взаимно блокируют друг друга.

**Классический deadlock:**
```
Транзакция A: Блокирует ресурс R1, запрашивает R2
Транзакция B: Блокирует ресурс R2, запрашивает R1
→ ВЗАИМНАЯ БЛОКИРОВКА (deadlock)
```

**Пример deadlock в T-SQL:**
```sql
-- Сессия 1
BEGIN TRANSACTION;
    UPDATE Accounts SET Balance = Balance - 100 WHERE ID = 1; -- Блокирует строку 1
    WAITFOR DELAY '00:00:05';  -- Имитация задержки
    UPDATE Accounts SET Balance = Balance + 100 WHERE ID = 2; -- Ждет строку 2

-- Сессия 2 (параллельно)
BEGIN TRANSACTION;
    UPDATE Accounts SET Balance = Balance - 50 WHERE ID = 2; -- Блокирует строку 2
    WAITFOR DELAY '00:00:05';
    UPDATE Accounts SET Balance = Balance + 50 WHERE ID = 1; -- Ждет строку 1 → DEADLOCK
```

**Обнаружение и обработка deadlocks:**
```sql
-- Настройка deadlock priority
SET DEADLOCK_PRIORITY LOW;  -- Первая жертва при deadlock
SET DEADLOCK_PRIORITY HIGH; -- Последняя жертва
SET DEADLOCK_PRIORITY NORMAL; -- По умолчанию

-- Мониторинг deadlocks
SELECT * FROM sys.dm_tran_locks;  -- Текущие блокировки
EXEC sp_lock;  -- Устаревший, но простой способ

-- Журнал deadlocks
SELECT * FROM sys.event_log 
WHERE event_type = 'deadlock';

-- Трассировка deadlocks
DBCC TRACEON (1222, -1);  -- Запись deadlock graph в errorlog
```

**Стратегии предотвращения deadlocks:**
1.  **Одинаковый порядок доступа:** Всегда блокировать ресурсы в одном порядке
2.  **Короткие транзакции:** Минимизировать время удержания блокировок
3.  **Использование SNAPSHOT изоляции:** Уменьшает блокировки
4.  **Оптимистическая блокировка:** Проверка версий при COMMIT

---

### **Часть 4. Журнал транзакций для защиты и восстановления**

#### **4.1. Архитектура журнала транзакций (Transaction Log)**

**Журнал транзакций** — это циклический файл, в который записываются **все изменения данных** перед их записью в основные файлы БД.

**Физическая структура:**
```
Транзакционный журнал (LDF файл)
├── Активная часть (Active Log)
│   ├── Виртуальные файлы журнала (VLF1, VLF2, ...)
│   └── Текущий VLF с указателем записи
├── Неактивная часть (Inactive Log)
└── Резервная копия (при наличии)
```

#### **4.2. Принцип Write-Ahead Logging (WAL)**

**Основное правило:** **Никакое изменение не может быть записано в данные, пока не записано в журнал.**

**Последовательность операций:**
```
1. Транзакция изменяет данные в буферном пуле (память)
2. Запись журнала синхронно сбрасывается на диск
3. Клиенту отправляется подтверждение COMMIT
4. "Грязные" страницы асинхронно записываются на диск
```

#### **4.3. Использование журнала для восстановления**

**Фазы восстановления после сбоя:**

**1. Фаза анализа (Analysis):**
```sql
-- Определение состояния на момент сбоя
-- Поиск последней контрольной точки
-- Построение списков UNDO и REDO
```

**2. Фаза повтора (Redo / Forward Recovery):**
```sql
-- Применение зафиксированных изменений
-- которые не попали в данные на диске
-- Начинается с последней контрольной точки
REDO: INSERT, UPDATE, DELETE, CREATE, ALTER, DROP
```

**3. Фаза отката (Undo / Backward Recovery):**
```sql
-- Откат незавершенных транзакций
-- Использование записей компенсации (Compensation Log Records)
UNDO: отмена изменений активных на момент сбоя транзакций
```

#### **4.4. Управление журналом транзакций**

**Резервное копирование журнала:**
```sql
-- Полная модель восстановления
ALTER DATABASE MyDB SET RECOVERY FULL;

-- Резервная копия журнала
BACKUP LOG MyDB TO DISK = 'D:\Backups\MyDB_log.bak';

-- Транзакции с момента последнего BACKUP LOG
BEGIN TRANSACTION;
    INSERT INTO BigTable ... ;  -- 1 млн строк
COMMIT;
-- Размер журнала растет

BACKUP LOG MyDB TO DISK = 'D:\Backups\MyDB_log2.bak';
-- Теперь можно усечь неактивную часть журнала
```

**Модели восстановления:**
```sql
-- 1. SIMPLE (Простая)
-- Автоматическое усечение журнала, нельзя делать backup log
ALTER DATABASE MyDB SET RECOVERY SIMPLE;

-- 2. FULL (Полная)
-- Полное журналирование, point-in-time восстановление
ALTER DATABASE MyDB SET RECOVERY FULL;

-- 3. BULK_LOGGED (Массово регистрируемая)
-- Минимальное журналирование массовых операций
ALTER DATABASE MyDB SET RECOVERY BULK_LOGGED;
```

**Мониторинг журнала:**
```sql
-- Использование журнала
DBCC SQLPERF(LOGSPACE);

-- Активные транзакции
DBCC OPENTRAN;

-- Размер и использование VLFs
SELECT 
    name,
    log_reuse_wait_desc,
    recovery_model_desc
FROM sys.databases 
WHERE name = DB_NAME();

-- Критические транзакции
SELECT 
    session_id,
    transaction_id,
    database_transaction_log_bytes_used
FROM sys.dm_tran_database_transactions
WHERE database_id = DB_ID();
```

#### **4.5. Point-in-Time Recovery (PITR)**

**Восстановление на конкретный момент времени:**
```sql
-- 1. Полная резервная копия
BACKUP DATABASE MyDB TO DISK = 'D:\Backups\MyDB_full.bak';

-- 2. Несколько резервных копий журнала
BACKUP LOG MyDB TO DISK = 'D:\Backups\MyDB_log1.bak';
-- ... операции ...
BACKUP LOG MyDB TO DISK = 'D:\Backups\MyDB_log2.bak';

-- 3. Восстановление на момент времени
RESTORE DATABASE MyDB FROM DISK = 'D:\Backups\MyDB_full.bak'
WITH NORECOVERY, REPLACE;

RESTORE LOG MyDB FROM DISK = 'D:\Backups\MyDB_log1.bak'
WITH NORECOVERY;

RESTORE LOG MyDB FROM DISK = 'D:\Backups\MyDB_log2.bak'
WITH RECOVERY, STOPAT = '2024-12-18 14:30:00';
-- БД восстановлена на 14:30 18 декабря
```

#### **4.6. Практические сценарии использования журнала**

**Сценарий 1: Аварийное восстановление**
```sql
-- После сбоя оборудования
RESTORE DATABASE MyDB FROM DISK = 'last_full_backup.bak'
WITH NORECOVERY;

-- Применить все журналы транзакций
RESTORE LOG MyDB FROM DISK = 'log1.bak' WITH NORECOVERY;
RESTORE LOG MyDB FROM DISK = 'log2.bak' WITH NORECOVERY;
...
RESTORE LOG MyDB FROM DISK = 'last_log.bak' WITH RECOVERY;
```

**Сценарий 2: Отмена ошибочной операции**
```sql
-- Если разработчик выполнил DELETE без WHERE
-- И у вас есть резервная копия журнала

-- 1. Создать резервную копию "хвоста" журнала
BACKUP LOG MyDB TO DISK = 'tail.bak'
WITH NORECOVERY;

-- 2. Восстановить из полной копии
RESTORE DATABASE MyDB FROM DISK = 'full_backup.bak'
WITH NORECOVERY, REPLACE;

-- 3. Восстановить журналы до момента ошибки
RESTORE LOG MyDB FROM DISK = 'log1.bak' WITH NORECOVERY;
...
RESTORE LOG MyDB FROM DISK = 'tail.bak' 
WITH RECOVERY, STOPBEFOREMARK = 'before_delete';
```

---

### **5. Интеграция всех компонентов: пример реальной системы**

```sql
-- Настройка надежной БД для финансовой системы
ALTER DATABASE BankDB 
SET RECOVERY FULL;  -- Для point-in-time восстановления

ALTER DATABASE BankDB 
SET READ_COMMITTED_SNAPSHOT ON;  -- Улучшение параллелизма

-- Критическая финансовая транзакция
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN TRANSACTION;

BEGIN TRY
    -- Блокировка для предотвращения deadlock
    UPDATE Accounts WITH (ROWLOCK, XLOCK) 
    SET Balance = Balance - 1000 
    WHERE AccountID = 123 AND Balance >= 1000;
    
    -- Проверка успешности
    IF @@ROWCOUNT = 0
    BEGIN
        ROLLBACK;
        RAISERROR('Недостаточно средств', 16, 1);
        RETURN;
    END
    
    UPDATE Accounts WITH (ROWLOCK)
    SET Balance = Balance + 1000 
    WHERE AccountID = 456;
    
    INSERT INTO Transactions (...) VALUES (...);
    
    -- Фиксация с гарантией записи в журнал
    COMMIT TRANSACTION WITH (DELAYED_DURABILITY = OFF);
    
END TRY
BEGIN CATCH
    ROLLBACK TRANSACTION;
    -- Логирование ошибки
    INSERT INTO ErrorLog (...) VALUES (...);
    THROW;
END CATCH
```

---

### **3. Заключение**

**Ключевые выводы:**

1.  **Транзакции — фундамент надежности:** ACID свойства обеспечивают корректность данных.
2.  **Изоляция — компромисс:** Между согласованностью и производительностью.
3.  **Блокировки — необходимое зло:** Требуют аккуратного управления для избежания deadlocks.
4.  **Журнал транзакций — страховка:** Позволяет восстановить данные после любых сбоев.

**Рекомендации для промышленных систем:**

1.  **Используйте подходящий уровень изоляции:** READ COMMITTED SNAPSHOT для большинства OLTP.
2.  **Пишите короткие транзакции:** Минимизируйте время удержания блокировок.
3.  **Мониторьте deadlocks:** Настройте оповещения и анализируйте причины.
4.  **Регулярно делайте backup log:** Для возможности point-in-time восстановления.
5.  **Следите за размером журнала:** Особенно при массовых операциях.
6.  **Тестируйте восстановление:** Регулярно проверяйте, что backup работают.

**Современные тенденции:**
- **MVCC вместо блокировок** (PostgreSQL, Oracle, SQL Server RCSI)
- **Оптимистическая блокировка** через версионирование
- **Распределенные транзакции** в микросервисных архитектурах
- **Журналирование в облачных хранилищах** для повышенной надежности

**Итог:** Понимание транзакций, изоляции, блокировок и журнала — это **базовые компетенции** для любого DBA и разработчика БД. Эти механизмы обеспечивают ту самую **надежность**, ради которой мы используем промышленные СУБД вместо файловых систем.